{"version":3,"file":"parse.js","names":["parse","text","caret_position","parse_character","context","value","focused_input_character_index","index","length","character","undefined","result","caret"],"sources":["../source/parse.js"],"sourcesContent":["// Parses the `text`.\r\n//\r\n// Returns `{ value, caret }` where `caret` is\r\n// the caret position inside `value`\r\n// corresponding to the `caret_position` inside `text`.\r\n//\r\n// The `text` is parsed by feeding each character sequentially to\r\n// `parse_character(character, value, context)` function\r\n// and appending the result (if it's not `undefined`) to `value`.\r\n//\r\n// `context` argument is just a utility empty object that is shared within the bounds\r\n// of parsing a single input string. The `_parse()` function could use that object\r\n// to store any kind of \"flags\" in it in order to alter its behavior based when\r\n// parsing next characters within the same string. Or it could completely ignore it.\r\n//\r\n// Example:\r\n//\r\n// `text` is `8 (800) 555-35-35`,\r\n// `caret_position` is `4` (before the first `0`).\r\n// `parse_character` is `(character, value) =>\r\n//   if (character >= '0' && character <= '9') { return character }`.\r\n//\r\n// then `parse()` outputs `{ value: '88005553535', caret: 2 }`.\r\n//\r\nexport default function parse(text, caret_position, parse_character)\r\n{\r\n\tconst context = {}\r\n\r\n\tlet value = ''\r\n\r\n\tlet focused_input_character_index = 0\r\n\r\n\tlet index = 0\r\n\twhile (index < text.length)\r\n\t{\r\n\t\tconst character = parse_character(text[index], value, context)\r\n\r\n\t\tif (character !== undefined)\r\n\t\t{\r\n\t\t\tvalue += character\r\n\r\n\t\t\tif (caret_position !== undefined)\r\n\t\t\t{\r\n\t\t\t\tif (caret_position === index)\r\n\t\t\t\t{\r\n\t\t\t\t\tfocused_input_character_index = value.length - 1;\r\n\t\t\t\t}\r\n\t\t\t\telse if (caret_position > index)\r\n\t\t\t\t{\r\n\t\t\t\t\tfocused_input_character_index = value.length\r\n\t\t\t\t}\r\n\t\t\t }\r\n\t\t}\r\n\r\n\t\tindex++\r\n\t}\r\n\r\n\t// If caret position wasn't specified\r\n\tif (caret_position === undefined)\r\n\t{\r\n\t\t// Then set caret position to \"after the last input character\"\r\n\t\tfocused_input_character_index = value.length\r\n\t}\r\n\r\n\tconst result =\r\n\t{\r\n\t\tvalue,\r\n\t\tcaret : focused_input_character_index\r\n\t}\r\n\r\n\treturn result\r\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,KAAT,CAAeC,IAAf,EAAqBC,cAArB,EAAqCC,eAArC,EACf;EACC,IAAMC,OAAO,GAAG,EAAhB;EAEA,IAAIC,KAAK,GAAG,EAAZ;EAEA,IAAIC,6BAA6B,GAAG,CAApC;EAEA,IAAIC,KAAK,GAAG,CAAZ;;EACA,OAAOA,KAAK,GAAGN,IAAI,CAACO,MAApB,EACA;IACC,IAAMC,SAAS,GAAGN,eAAe,CAACF,IAAI,CAACM,KAAD,CAAL,EAAcF,KAAd,EAAqBD,OAArB,CAAjC;;IAEA,IAAIK,SAAS,KAAKC,SAAlB,EACA;MACCL,KAAK,IAAII,SAAT;;MAEA,IAAIP,cAAc,KAAKQ,SAAvB,EACA;QACC,IAAIR,cAAc,KAAKK,KAAvB,EACA;UACCD,6BAA6B,GAAGD,KAAK,CAACG,MAAN,GAAe,CAA/C;QACA,CAHD,MAIK,IAAIN,cAAc,GAAGK,KAArB,EACL;UACCD,6BAA6B,GAAGD,KAAK,CAACG,MAAtC;QACA;MACA;IACF;;IAEDD,KAAK;EACL,CA9BF,CAgCC;;;EACA,IAAIL,cAAc,KAAKQ,SAAvB,EACA;IACC;IACAJ,6BAA6B,GAAGD,KAAK,CAACG,MAAtC;EACA;;EAED,IAAMG,MAAM,GACZ;IACCN,KAAK,EAALA,KADD;IAECO,KAAK,EAAGN;EAFT,CADA;EAMA,OAAOK,MAAP;AACA"}