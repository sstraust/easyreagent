{
"version":3,
"file":"module$node_modules$libphonenumber_js$build$helpers$extractNationalNumberFromPossiblyIncompleteNumber.js",
"lineCount":17,
"mappings":"AAAAA,cAAA,CAAA,qGAAA,GAA0H,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAGlKC,QAAOC,CAAAA,cAAP,CAAsBF,OAAtB,EAA+B,YAA/B,EAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGAH,SAAA,CAAQ,SAAR,CAAA,GAeAI,QAA0D,CAACC,MAAD,EAASC,QAAT,CAAmB;AAC3E,QAAID,MAAJ,IAAcC,QAASC,CAAAA,aAAcC,CAAAA,wBAAvB,EAAd,CAAiE;AAI/D,UAAIC,gBAAgB,IAAIC,MAAJ,CAAW,MAAX,GAAoBJ,QAASC,CAAAA,aAAcC,CAAAA,wBAAvB,EAApB,GAAwE,GAAxE,CAApB,EACIG,cAAcF,aAAcG,CAAAA,IAAd,CAAmBP,MAAnB,CADlB;AAGA,UAAIM,WAAJ,CAAiB;AAEf,YAAIE,WAAJ,EAiBIC,sBAAsBH,WAAYI,CAAAA,MAAlCD,GAA2C,CAjB/C,EAkBIE,oBAA0C,CAA1CA,GAAoBF,mBAApBE,IAA+CL,WAAA,CAAYG,mBAAZ,CAlBnD;AAoBIR,gBAASW,CAAAA,2BAAT,EAAJ,IAA8CD,iBAA9C,IACEE,aAGA,GAHiBb,MAAOc,CAAAA,OAAP,CAAeV,aAAf,EAA8BH,QAASW,CAAAA,2BAAT,EAA9B,CAGjB,EAA0B,CAA1B,GAAIH,mBAAJ,KACED,WADF,GACgBF,WAAA,CAAY,CAAZ,CADhB,CAJF,KAoBEO,aAGA,GAHiBb,MAAOe,CAAAA,KAAP,CADgBT,WAAAU,CAAY,CAAZA,CACwBN,CAAAA,MAAxC,CAGjB,EAAIC,iBAAJ,KACEH,WADF,GACgBF,WAAA,CAAY,CAAZ,CADhB,CAvBF,CAAA;AAiCA,YAAIW,cAAJ;AAEIN,yBAAJ,IACMO,WAQJ,GAR8ClB,MAAOmB,CAAAA,OAAP,CAAeb,WAAA,CAAY,CAAZ,CAAf,CAQ9C,EAP6BN,MAAOe,CAAAA,KAAPK,CAAa,CAAbA,EAAgBF,WAAhBE,CAO7B,KAA+BnB,QAASC,CAAAA,aAAce,CAAAA,cAAvB,EAA/B,KACEA,cADF,GACmBhB,QAASC,CAAAA,aAAce,CAAAA,cAAvB,EADnB,CATF,IAaEA,cAbF,GAamBX,WAAA,CAAY,CAAZ,CAbnB;AAgBA,eAAO,CACLO,eAAgBA,aADX,EAEWI,cAFX,EAGQT,WAHR,CAAP;AAzEe;AAP8C;AAwFjE,WAAO,CACLK,eAAgBb,MADX,CAAP;AAzF2E,GAf7E;AANkK,CAAlK;;",
"sources":["node_modules/libphonenumber-js/build/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$libphonenumber_js$build$helpers$extractNationalNumberFromPossiblyIncompleteNumber\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = extractNationalNumberFromPossiblyIncompleteNumber;\n\n/**\r\n * Strips any national prefix (such as 0, 1) present in a\r\n * (possibly incomplete) number provided.\r\n * \"Carrier codes\" are only used  in Colombia and Brazil,\r\n * and only when dialing within those countries from a mobile phone to a fixed line number.\r\n * Sometimes it won't actually strip national prefix\r\n * and will instead prepend some digits to the `number`:\r\n * for example, when number `2345678` is passed with `VI` country selected,\r\n * it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n * @param {string} number \u2014 National number digits.\r\n * @param {object} metadata \u2014 Metadata with country selected.\r\n * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.\r\n */\nfunction extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {\n  if (number && metadata.numberingPlan.nationalPrefixForParsing()) {\n    // See METADATA.md for the description of\n    // `national_prefix_for_parsing` and `national_prefix_transform_rule`.\n    // Attempt to parse the first digits as a national prefix.\n    var prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')');\n    var prefixMatch = prefixPattern.exec(number);\n\n    if (prefixMatch) {\n      var nationalNumber;\n      var carrierCode; // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n      // If a `national_prefix_for_parsing` has any \"capturing groups\"\n      // then it means that the national (significant) number is equal to\n      // those \"capturing groups\" transformed via `national_prefix_transform_rule`,\n      // and nothing could be said about the actual national prefix:\n      // what is it and was it even there.\n      // If a `national_prefix_for_parsing` doesn't have any \"capturing groups\",\n      // then everything it matches is a national prefix.\n      // To determine whether `national_prefix_for_parsing` matched any\n      // \"capturing groups\", the value of the result of calling `.exec()`\n      // is looked at, and if it has non-undefined values where there're\n      // \"capturing groups\" in the regular expression, then it means\n      // that \"capturing groups\" have been matched.\n      // It's not possible to tell whether there'll be any \"capturing gropus\"\n      // before the matching process, because a `national_prefix_for_parsing`\n      // could exhibit both behaviors.\n\n      var capturedGroupsCount = prefixMatch.length - 1;\n      var hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount];\n\n      if (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {\n        nationalNumber = number.replace(prefixPattern, metadata.nationalPrefixTransformRule()); // If there's more than one captured group,\n        // then carrier code is the second one.\n\n        if (capturedGroupsCount > 1) {\n          carrierCode = prefixMatch[1];\n        }\n      } // If there're no \"capturing groups\",\n      // or if there're \"capturing groups\" but no\n      // `national_prefix_transform_rule`,\n      // then just strip the national prefix from the number,\n      // and possibly a carrier code.\n      // Seems like there could be more.\n      else {\n        // `prefixBeforeNationalNumber` is the whole substring matched by\n        // the `national_prefix_for_parsing` regular expression.\n        // There seem to be no guarantees that it's just a national prefix.\n        // For example, if there's a carrier code, it's gonna be a\n        // part of `prefixBeforeNationalNumber` too.\n        var prefixBeforeNationalNumber = prefixMatch[0];\n        nationalNumber = number.slice(prefixBeforeNationalNumber.length); // If there's at least one captured group,\n        // then carrier code is the first one.\n\n        if (hasCapturedGroups) {\n          carrierCode = prefixMatch[1];\n        }\n      } // Tries to guess whether a national prefix was present in the input.\n      // This is not something copy-pasted from Google's library:\n      // they don't seem to have an equivalent for that.\n      // So this isn't an \"officially approved\" way of doing something like that.\n      // But since there seems no other existing method, this library uses it.\n\n\n      var nationalPrefix;\n\n      if (hasCapturedGroups) {\n        var possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1]);\n        var possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup); // Example: an Argentinian (AR) phone number `0111523456789`.\n        // `prefixMatch[0]` is `01115`, and `$1` is `11`,\n        // and the rest of the phone number is `23456789`.\n        // The national number is transformed via `9$1` to `91123456789`.\n        // National prefix `0` is detected being present at the start.\n        // if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {\n\n        if (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {\n          nationalPrefix = metadata.numberingPlan.nationalPrefix();\n        }\n      } else {\n        nationalPrefix = prefixMatch[0];\n      }\n\n      return {\n        nationalNumber: nationalNumber,\n        nationalPrefix: nationalPrefix,\n        carrierCode: carrierCode\n      };\n    }\n  }\n\n  return {\n    nationalNumber: number\n  };\n}\n//# sourceMappingURL=extractNationalNumberFromPossiblyIncompleteNumber.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","extractNationalNumberFromPossiblyIncompleteNumber","number","metadata","numberingPlan","nationalPrefixForParsing","prefixPattern","RegExp","prefixMatch","exec","carrierCode","capturedGroupsCount","length","hasCapturedGroups","nationalPrefixTransformRule","nationalNumber","replace","slice","prefixBeforeNationalNumber","nationalPrefix","possiblePositionOfTheFirstCapturedGroup","indexOf","possibleNationalPrefix"]
}
