{
"version":3,
"file":"module$node_modules$libphonenumber_js$build$findNumbers$Leniency.js",
"lineCount":77,
"mappings":"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",
"sources":["node_modules/libphonenumber-js/build/findNumbers/Leniency.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$libphonenumber_js$build$findNumbers$Leniency\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.containsMoreThanOneSlashInNationalNumber = containsMoreThanOneSlashInNationalNumber;\nexports[\"default\"] = void 0;\n\nvar _isValid = _interopRequireDefault(require(\"../isValid.js\"));\n\nvar _parseDigits = _interopRequireDefault(require(\"../helpers/parseDigits.js\"));\n\nvar _matchPhoneNumberStringAgainstPhoneNumber = _interopRequireDefault(require(\"./matchPhoneNumberStringAgainstPhoneNumber.js\"));\n\nvar _metadata2 = _interopRequireDefault(require(\"../metadata.js\"));\n\nvar _getCountryByCallingCode = _interopRequireDefault(require(\"../helpers/getCountryByCallingCode.js\"));\n\nvar _format = require(\"../format.js\");\n\nvar _util = require(\"./util.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\nvar _default = {\n  /**\r\n   * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n   */\n  POSSIBLE: function POSSIBLE(phoneNumber, _ref) {\n    var candidate = _ref.candidate,\n        metadata = _ref.metadata;\n    return true;\n  },\n\n  /**\r\n   * Phone numbers accepted are \"possible\" and \"valid\".\r\n   * Numbers written in national format must have their national-prefix\r\n   * present if it is usually written for a number of this type.\r\n   */\n  VALID: function VALID(phoneNumber, _ref2) {\n    var candidate = _ref2.candidate,\n        defaultCountry = _ref2.defaultCountry,\n        metadata = _ref2.metadata;\n\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata)) {\n      return false;\n    } // Skipped for simplicity.\n    // return isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })\n\n\n    return true;\n  },\n\n  /**\r\n   * Phone numbers accepted are \"valid\" and\r\n   * are grouped in a possible way for this locale. For example, a US number written as\r\n   * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n   * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol in the national significant number\r\n   * are also dropped at this level.\r\n   *\r\n   * Warning: This level might result in lower coverage especially for regions outside of\r\n   * country code \"+1\". If you are not sure about which level to use,\r\n   * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n   */\n  STRICT_GROUPING: function STRICT_GROUPING(phoneNumber, _ref3) {\n    var candidate = _ref3.candidate,\n        defaultCountry = _ref3.defaultCountry,\n        metadata = _ref3.metadata,\n        regExpCache = _ref3.regExpCache;\n\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {\n      defaultCountry: defaultCountry,\n      metadata: metadata\n    })) {\n      return false;\n    }\n\n    return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);\n  },\n\n  /**\r\n   * Phone numbers accepted are \"valid\" and are grouped in the same way\r\n   * that we would have formatted it, or as a single block.\r\n   * For example, a US number written as \"650 2530000\" is not accepted\r\n   * at this leniency level, whereas \"650 253 0000\" or \"6502530000\" are.\r\n   * Numbers with more than one '/' symbol are also dropped at this level.\r\n   *\r\n   * Warning: This level might result in lower coverage especially for regions outside of\r\n   * country code \"+1\". If you are not sure about which level to use, email the discussion group\r\n   * libphonenumber-discuss@googlegroups.com.\r\n   */\n  EXACT_GROUPING: function EXACT_GROUPING(phoneNumber, _ref4) {\n    var candidate = _ref4.candidate,\n        defaultCountry = _ref4.defaultCountry,\n        metadata = _ref4.metadata,\n        regExpCache = _ref4.regExpCache;\n\n    if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {\n      defaultCountry: defaultCountry,\n      metadata: metadata\n    })) {\n      return false;\n    }\n\n    return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);\n  }\n};\nexports[\"default\"] = _default;\n\nfunction containsOnlyValidXChars(phoneNumber, candidate, metadata) {\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\n  // national significant number or (2) an extension sign, in which case they always precede the\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\n  // or 'X'. We ignore the character if it appears as the last character of the string.\n  for (var index = 0; index < candidate.length - 1; index++) {\n    var charAtIndex = candidate.charAt(index);\n\n    if (charAtIndex === 'x' || charAtIndex === 'X') {\n      var charAtNextIndex = candidate.charAt(index + 1);\n\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X') {\n        // This is the carrier code case, in which the 'X's always precede the national\n        // significant number.\n        index++;\n\n        if ((0, _matchPhoneNumberStringAgainstPhoneNumber[\"default\"])(candidate.substring(index), phoneNumber, metadata) !== 'NSN_MATCH') {\n          return false;\n        } // This is the extension sign case, in which the 'x' or 'X' should always precede the\n        // extension number.\n\n      } else {\n        var ext = (0, _parseDigits[\"default\"])(candidate.substring(index));\n\n        if (ext) {\n          if (phoneNumber.ext !== ext) {\n            return false;\n          }\n        } else {\n          if (phoneNumber.ext) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction isNationalPrefixPresentIfRequired(phoneNumber, _ref5) {\n  var defaultCountry = _ref5.defaultCountry,\n      _metadata = _ref5.metadata;\n\n  // First, check how we deduced the country code. If it was written in international format, then\n  // the national prefix is not required.\n  if (phoneNumber.__countryCallingCodeSource !== 'FROM_DEFAULT_COUNTRY') {\n    return true;\n  }\n\n  var metadata = new _metadata2[\"default\"](_metadata);\n  metadata.selectNumberingPlan(phoneNumber.countryCallingCode);\n  var phoneNumberRegion = phoneNumber.country || (0, _getCountryByCallingCode[\"default\"])(phoneNumber.countryCallingCode, {\n    nationalNumber: phoneNumber.nationalNumber,\n    defaultCountry: defaultCountry,\n    metadata: metadata\n  }); // Check if a national prefix should be present when formatting this number.\n\n  var nationalNumber = phoneNumber.nationalNumber;\n  var format = (0, _format.chooseFormatForNumber)(metadata.numberingPlan.formats(), nationalNumber); // To do this, we check that a national prefix formatting rule was present\n  // and that it wasn't just the first-group symbol ($1) with punctuation.\n\n  if (format.nationalPrefixFormattingRule()) {\n    if (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\n      // The national-prefix is optional in these cases, so we don't need to check if it was present.\n      return true;\n    }\n\n    if (!format.usesNationalPrefix()) {\n      // National Prefix not needed for this number.\n      return true;\n    }\n\n    return Boolean(phoneNumber.nationalPrefix);\n  }\n\n  return true;\n}\n\nfunction containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) {\n  var firstSlashInBodyIndex = candidate.indexOf('/');\n\n  if (firstSlashInBodyIndex < 0) {\n    // No slashes, this is okay.\n    return false;\n  } // Now look for a second one.\n\n\n  var secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1);\n\n  if (secondSlashInBodyIndex < 0) {\n    // Only one slash, this is okay.\n    return false;\n  } // If the first slash is after the country calling code, this is permitted.\n\n\n  var candidateHasCountryCode = phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITH_PLUS_SIGN' || phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITHOUT_PLUS_SIGN';\n\n  if (candidateHasCountryCode && (0, _parseDigits[\"default\"])(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode) {\n    // Any more slashes and this is illegal.\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0;\n  }\n\n  return true;\n}\n\nfunction checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {\n  throw new Error('This part of code hasn\\'t been ported');\n  var normalizedCandidate = normalizeDigits(candidate, true\n  /* keep non-digits */\n  );\n  var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);\n\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n    return true;\n  } // If this didn't pass, see if there are any alternate formats that match, and try them instead.\n\n\n  var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());\n  var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n\n  if (alternateFormats) {\n    for (var _iterator = _createForOfIteratorHelperLoose(alternateFormats.numberFormats()), _step; !(_step = _iterator()).done;) {\n      var alternateFormat = _step.value;\n\n      if (alternateFormat.leadingDigitsPatterns().length > 0) {\n        // There is only one leading digits pattern for alternate formats.\n        var leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0]);\n\n        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\n          // Leading digits don't match; try another one.\n          continue;\n        }\n      }\n\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);\n\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\n\n\nfunction getNationalNumberGroups(metadata, number, formattingPattern) {\n  throw new Error('This part of code hasn\\'t been ported');\n\n  if (formattingPattern) {\n    // We format the NSN only, and split that according to the separator.\n    var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n    return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, 'RFC3966', metadata).split('-');\n  } // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\n\n\n  var rfc3966Format = formatNumber(number, 'RFC3966', metadata); // We remove the extension part from the formatted string before splitting it into different\n  // groups.\n\n  var endIndex = rfc3966Format.indexOf(';');\n\n  if (endIndex < 0) {\n    endIndex = rfc3966Format.length;\n  } // The country-code will have a '-' following it.\n\n\n  var startIndex = rfc3966Format.indexOf('-') + 1;\n  return rfc3966Format.slice(startIndex, endIndex).split('-');\n}\n\nfunction allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  throw new Error('This part of code hasn\\'t been ported');\n  var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN); // Set this to the last group, skipping it if the number has an extension.\n\n  var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1; // First we check if the national significant number is formatted as a block.\n  // We use contains and not equals, since the national significant number may be present with\n  // a prefix such as a national number prefix, or the country code itself.\n\n  if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {\n    return true;\n  } // Starting from the end, go through in reverse, excluding the first group, and check the\n  // candidate and number groups are the same.\n\n\n  var formattedNumberGroupIndex = formattedNumberGroups.length - 1;\n\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {\n      return false;\n    }\n\n    formattedNumberGroupIndex--;\n    candidateNumberGroupIndex--;\n  } // Now check the first group. There may be a national prefix at the start, so we only check\n  // that the candidate group ends with the formatted number group.\n\n\n  return candidateNumberGroupIndex >= 0 && (0, _util.endsWith)(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);\n}\n\nfunction allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {\n  throw new Error('This part of code hasn\\'t been ported');\n  var fromIndex = 0;\n\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {\n    // First skip the country code if the normalized candidate contained it.\n    var countryCode = String(number.getCountryCode());\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();\n  } // Check each group of consecutive digits are not broken into separate groupings in the\n  // {@code normalizedCandidate} string.\n\n\n  for (var i = 0; i < formattedNumberGroups.length; i++) {\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);\n\n    if (fromIndex < 0) {\n      return false;\n    } // Moves {@code fromIndex} forward.\n\n\n    fromIndex += formattedNumberGroups[i].length();\n\n    if (i == 0 && fromIndex < normalizedCandidate.length()) {\n      // We are at the position right after the NDC. We get the region used for formatting\n      // information based on the country code in the phone number, rather than the number itself,\n      // as we do not need to distinguish between different countries with the same country\n      // calling code and this is faster.\n      var region = util.getRegionCodeForCountryCode(number.getCountryCode());\n\n      if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\n        // This means there is no formatting symbol after the NDC. In this case, we only\n        // accept the number if there is no formatting symbol at all in the number, except\n        // for extensions. This is only important for countries with national prefixes.\n        var nationalSignificantNumber = util.getNationalSignificantNumber(number);\n        return (0, _util.startsWith)(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);\n      }\n    }\n  } // The check here makes sure that we haven't mistakenly already used the extension to\n  // match the last group of the subscriber number. Note the extension cannot have\n  // formatting in-between digits.\n\n\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension());\n}\n//# sourceMappingURL=Leniency.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","obj","__esModule","containsOnlyValidXChars","phoneNumber","candidate","metadata","index","length","charAtIndex","charAt","charAtNextIndex","_matchPhoneNumberStringAgainstPhoneNumber","substring","ext","_parseDigits","isNationalPrefixPresentIfRequired","_ref5","defaultCountry","__countryCallingCodeSource","_metadata2","selectNumberingPlan","countryCallingCode","country","_getCountryByCallingCode","nationalNumber","format","_format","chooseFormatForNumber","numberingPlan","formats","nationalPrefixFormattingRule","nationalPrefixIsOptionalWhenFormattingInNationalFormat","usesNationalPrefix","nationalPrefix","containsMoreThanOneSlashInNationalNumber","firstSlashInBodyIndex","indexOf","secondSlashInBodyIndex","slice","Object","defineProperty","value","_default","POSSIBLE","_ref","VALID","_ref2","isValid","STRICT_GROUPING","_ref3","Error","EXACT_GROUPING","_ref4"]
}
