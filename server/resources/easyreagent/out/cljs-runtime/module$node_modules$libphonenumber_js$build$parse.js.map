{
"version":3,
"file":"module$node_modules$libphonenumber_js$build$parse.js",
"lineCount":162,
"mappings":"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",
"sources":["node_modules/libphonenumber-js/build/parse.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$libphonenumber_js$build$parse\"] = function(global,require,module,exports) {\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = parse;\n\nvar _constants = require(\"./constants.js\");\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError.js\"));\n\nvar _metadata = _interopRequireDefault(require(\"./metadata.js\"));\n\nvar _isViablePhoneNumber = _interopRequireWildcard(require(\"./helpers/isViablePhoneNumber.js\"));\n\nvar _extractExtension = _interopRequireDefault(require(\"./helpers/extension/extractExtension.js\"));\n\nvar _parseIncompletePhoneNumber = _interopRequireDefault(require(\"./parseIncompletePhoneNumber.js\"));\n\nvar _getCountryCallingCode = _interopRequireDefault(require(\"./getCountryCallingCode.js\"));\n\nvar _isPossible = require(\"./isPossible.js\");\n\nvar _PhoneNumber = _interopRequireDefault(require(\"./PhoneNumber.js\"));\n\nvar _matchesEntirely = _interopRequireDefault(require(\"./helpers/matchesEntirely.js\"));\n\nvar _extractCountryCallingCode = _interopRequireDefault(require(\"./helpers/extractCountryCallingCode.js\"));\n\nvar _extractNationalNumber = _interopRequireDefault(require(\"./helpers/extractNationalNumber.js\"));\n\nvar _stripIddPrefix = _interopRequireDefault(require(\"./helpers/stripIddPrefix.js\"));\n\nvar _getCountryByCallingCode = _interopRequireDefault(require(\"./helpers/getCountryByCallingCode.js\"));\n\nvar _extractFormattedPhoneNumberFromPossibleRfc3966NumberUri = _interopRequireDefault(require(\"./helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n// import { parseRFC3966 } from './helpers/RFC3966.js'\n// We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\nvar MAX_INPUT_STRING_LENGTH = 250; // This consists of the plus symbol, digits, and arabic-indic digits.\n\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + _constants.PLUS_CHARS + _constants.VALID_DIGITS + ']'); // Regular expression of trailing characters that we want to remove.\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\n\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + _constants.VALID_DIGITS + '#' + ']+$');\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false; // Examples:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\n\n/**\r\n * Parses a phone number.\r\n *\r\n * parse('123456789', { defaultCountry: 'RU', v2: true }, metadata)\r\n * parse('123456789', { defaultCountry: 'RU' }, metadata)\r\n * parse('123456789', undefined, metadata)\r\n *\r\n * @param  {string} input\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {object|PhoneNumber?} If `options.v2: true` flag is passed, it returns a `PhoneNumber?` instance. Otherwise, returns an object of shape `{ phone: '...', country: '...' }` (or just `{}` if no phone number was parsed).\r\n */\n\nfunction parse(text, options, metadata) {\n  // If assigning the `{}` default value is moved to the arguments above,\n  // code coverage would decrease for some weird reason.\n  options = options || {};\n  metadata = new _metadata[\"default\"](metadata); // Validate `defaultCountry`.\n\n  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\n    if (options.v2) {\n      throw new _ParseError[\"default\"]('INVALID_COUNTRY');\n    }\n\n    throw new Error(\"Unknown country: \".concat(options.defaultCountry));\n  } // Parse the phone number.\n\n\n  var _parseInput = parseInput(text, options.v2, options.extract),\n      formattedPhoneNumber = _parseInput.number,\n      ext = _parseInput.ext,\n      error = _parseInput.error; // If the phone number is not viable then return nothing.\n\n\n  if (!formattedPhoneNumber) {\n    if (options.v2) {\n      if (error === 'TOO_SHORT') {\n        throw new _ParseError[\"default\"]('TOO_SHORT');\n      }\n\n      throw new _ParseError[\"default\"]('NOT_A_NUMBER');\n    }\n\n    return {};\n  }\n\n  var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata),\n      country = _parsePhoneNumber.country,\n      nationalNumber = _parsePhoneNumber.nationalNumber,\n      countryCallingCode = _parsePhoneNumber.countryCallingCode,\n      countryCallingCodeSource = _parsePhoneNumber.countryCallingCodeSource,\n      carrierCode = _parsePhoneNumber.carrierCode;\n\n  if (!metadata.hasSelectedNumberingPlan()) {\n    if (options.v2) {\n      throw new _ParseError[\"default\"]('INVALID_COUNTRY');\n    }\n\n    return {};\n  } // Validate national (significant) number length.\n\n\n  if (!nationalNumber || nationalNumber.length < _constants.MIN_LENGTH_FOR_NSN) {\n    // Won't throw here because the regexp already demands length > 1.\n\n    /* istanbul ignore if */\n    if (options.v2) {\n      throw new _ParseError[\"default\"]('TOO_SHORT');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  } // Validate national (significant) number length.\n  //\n  // A sidenote:\n  //\n  // They say that sometimes national (significant) numbers\n  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n  // Such numbers will just be discarded.\n  //\n\n\n  if (nationalNumber.length > _constants.MAX_LENGTH_FOR_NSN) {\n    if (options.v2) {\n      throw new _ParseError[\"default\"]('TOO_LONG');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  }\n\n  if (options.v2) {\n    var phoneNumber = new _PhoneNumber[\"default\"](countryCallingCode, nationalNumber, metadata.metadata);\n\n    if (country) {\n      phoneNumber.country = country;\n    }\n\n    if (carrierCode) {\n      phoneNumber.carrierCode = carrierCode;\n    }\n\n    if (ext) {\n      phoneNumber.ext = ext;\n    }\n\n    phoneNumber.__countryCallingCodeSource = countryCallingCodeSource;\n    return phoneNumber;\n  } // Check if national phone number pattern matches the number.\n  // National number pattern is different for each country,\n  // even for those ones which are part of the \"NANPA\" group.\n\n\n  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? (0, _matchesEntirely[\"default\"])(nationalNumber, metadata.nationalNumberPattern()) : false;\n\n  if (!options.extended) {\n    return valid ? result(country, nationalNumber, ext) : {};\n  } // isInternational: countryCallingCode !== undefined\n\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    carrierCode: carrierCode,\n    valid: valid,\n    possible: valid ? true : options.extended === true && metadata.possibleLengths() && (0, _isPossible.isPossibleNumber)(nationalNumber, metadata) ? true : false,\n    phone: nationalNumber,\n    ext: ext\n  };\n}\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} [extract] \u2014 If `false`, then will parse the entire `text` as a phone number.\r\n * @param  {boolean} [throwOnError] \u2014 By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\n\n\nfunction _extractFormattedPhoneNumber(text, extract, throwOnError) {\n  if (!text) {\n    return;\n  }\n\n  if (text.length > MAX_INPUT_STRING_LENGTH) {\n    if (throwOnError) {\n      throw new _ParseError[\"default\"]('TOO_LONG');\n    }\n\n    return;\n  }\n\n  if (extract === false) {\n    return text;\n  } // Attempt to extract a possible number from the string passed in\n\n\n  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);\n\n  if (startsAt < 0) {\n    return;\n  }\n\n  return text // Trim everything to the left of the phone number\n  .slice(startsAt) // Remove trailing non-numerical characters\n  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n}\n/**\r\n * @param  {string} text - Input.\r\n * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.\r\n * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\n\n\nfunction parseInput(text, v2, extract) {\n  // // Parse RFC 3966 phone number URI.\n  // if (text && text.indexOf('tel:') === 0) {\n  // \treturn parseRFC3966(text)\n  // }\n  // let number = extractFormattedPhoneNumber(text, extract, v2)\n  var number = (0, _extractFormattedPhoneNumberFromPossibleRfc3966NumberUri[\"default\"])(text, {\n    extractFormattedPhoneNumber: function extractFormattedPhoneNumber(text) {\n      return _extractFormattedPhoneNumber(text, extract, v2);\n    }\n  }); // If the phone number is not viable, then abort.\n\n  if (!number) {\n    return {};\n  }\n\n  if (!(0, _isViablePhoneNumber[\"default\"])(number)) {\n    if ((0, _isViablePhoneNumber.isViablePhoneNumberStart)(number)) {\n      return {\n        error: 'TOO_SHORT'\n      };\n    }\n\n    return {};\n  } // Attempt to parse extension first, since it doesn't require region-specific\n  // data and we want to have the non-normalised number here.\n\n\n  var withExtensionStripped = (0, _extractExtension[\"default\"])(number);\n\n  if (withExtensionStripped.ext) {\n    return withExtensionStripped;\n  }\n\n  return {\n    number: number\n  };\n}\n/**\r\n * Creates `parse()` result object.\r\n */\n\n\nfunction result(country, nationalNumber, ext) {\n  var result = {\n    country: country,\n    phone: nationalNumber\n  };\n\n  if (ext) {\n    result.ext = ext;\n  }\n\n  return result;\n}\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber \u2014 Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\n\n\nfunction parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {\n  // Extract calling code from phone number.\n  var _extractCountryCallin = (0, _extractCountryCallingCode[\"default\"])((0, _parseIncompletePhoneNumber[\"default\"])(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata),\n      countryCallingCodeSource = _extractCountryCallin.countryCallingCodeSource,\n      countryCallingCode = _extractCountryCallin.countryCallingCode,\n      number = _extractCountryCallin.number; // Choose a country by `countryCallingCode`.\n\n\n  var country;\n\n  if (countryCallingCode) {\n    metadata.selectNumberingPlan(countryCallingCode);\n  } // If `formattedPhoneNumber` is passed in \"national\" format\n  // then `number` is defined and `countryCallingCode` is `undefined`.\n  else if (number && (defaultCountry || defaultCallingCode)) {\n    metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);\n\n    if (defaultCountry) {\n      country = defaultCountry;\n    } else {\n      /* istanbul ignore if */\n      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n        if (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\n          country = '001';\n        }\n      }\n    }\n\n    countryCallingCode = defaultCallingCode || (0, _getCountryCallingCode[\"default\"])(defaultCountry, metadata.metadata);\n  } else return {};\n\n  if (!number) {\n    return {\n      countryCallingCodeSource: countryCallingCodeSource,\n      countryCallingCode: countryCallingCode\n    };\n  }\n\n  var _extractNationalNumbe = (0, _extractNationalNumber[\"default\"])((0, _parseIncompletePhoneNumber[\"default\"])(number), metadata),\n      nationalNumber = _extractNationalNumbe.nationalNumber,\n      carrierCode = _extractNationalNumbe.carrierCode; // Sometimes there are several countries\n  // corresponding to the same country phone code\n  // (e.g. NANPA countries all having `1` country phone code).\n  // Therefore, to reliably determine the exact country,\n  // national (significant) number should have been parsed first.\n  //\n  // When `metadata.json` is generated, all \"ambiguous\" country phone codes\n  // get their countries populated with the full set of\n  // \"phone number type\" regular expressions.\n  //\n\n\n  var exactCountry = (0, _getCountryByCallingCode[\"default\"])(countryCallingCode, {\n    nationalNumber: nationalNumber,\n    defaultCountry: defaultCountry,\n    metadata: metadata\n  });\n\n  if (exactCountry) {\n    country = exactCountry;\n    /* istanbul ignore if */\n\n    if (exactCountry === '001') {// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\n      // If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\n      // then remove the \"istanbul ignore if\".\n    } else {\n      metadata.country(country);\n    }\n  }\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    countryCallingCodeSource: countryCallingCodeSource,\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n}\n//# sourceMappingURL=parse.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","_typeof","obj","Symbol","iterator","constructor","prototype","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","_interopRequireDefault","__esModule","parseInput","text","v2","extract","number","_extractFormattedPhoneNumberFromPossibleRfc3966NumberUri","extractFormattedPhoneNumber","length","MAX_INPUT_STRING_LENGTH","_ParseError","startsAt","search","PHONE_NUMBER_START_PATTERN","slice","replace","AFTER_PHONE_NUMBER_END_PATTERN","_isViablePhoneNumber","isViablePhoneNumberStart","error","withExtensionStripped","_extractExtension","ext","Object","defineProperty","value","parse","options","metadata","_metadata","defaultCountry","hasCountry","Error","concat","_parseInput","formattedPhoneNumber","defaultCallingCode","_extractCountryCallin","_extractCountryCallingCode","_parseIncompletePhoneNumber","countryCallingCodeSource","countryCallingCode","selectNumberingPlan","country","USE_NON_GEOGRAPHIC_COUNTRY_CODE","isNonGeographicCallingCode","_getCountryCallingCode","_extractNationalNumbe","_extractNationalNumber","nationalNumber","carrierCode","exactCountry","_getCountryByCallingCode","hasSelectedNumberingPlan","_constants","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","phoneNumber","_PhoneNumber","__countryCallingCodeSource","valid","extended","_matchesEntirely","nationalNumberPattern","possible","possibleLengths","_isPossible","isPossibleNumber","phone","result","_interopRequireWildcard","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","hasOwnProperty","call","desc","set","RegExp","PLUS_CHARS","VALID_DIGITS"]
}
