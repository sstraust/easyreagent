{
"version":3,
"file":"module$node_modules$libphonenumber_js$build$AsYouTypeFormatter.js",
"lineCount":246,
"mappings":"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",
"sources":["node_modules/libphonenumber-js/build/AsYouTypeFormatter.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$libphonenumber_js$build$AsYouTypeFormatter\"] = function(global,require,module,exports) {\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"DIGIT_PLACEHOLDER\", {\n  enumerable: true,\n  get: function get() {\n    return _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER;\n  }\n});\nexports[\"default\"] = void 0;\n\nvar _AsYouTypeFormatterUtil = require(\"./AsYouTypeFormatter.util.js\");\n\nvar _AsYouTypeFormatterComplete = _interopRequireWildcard(require(\"./AsYouTypeFormatter.complete.js\"));\n\nvar _AsYouTypeFormatterPatternMatcher = _interopRequireDefault(require(\"./AsYouTypeFormatter.PatternMatcher.js\"));\n\nvar _parseDigits = _interopRequireDefault(require(\"./helpers/parseDigits.js\"));\n\nvar _formatNationalNumberUsingFormat = require(\"./helpers/formatNationalNumberUsingFormat.js\");\n\nvar _constants = require(\"./constants.js\");\n\nvar _applyInternationalSeparatorStyle = _interopRequireDefault(require(\"./helpers/applyInternationalSeparatorStyle.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n// Used in phone number format template creation.\n// Could be any digit, I guess.\nvar DUMMY_DIGIT = '9'; // I don't know why is it exactly `15`\n\nvar LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15; // Create a phone number consisting only of the digit 9 that matches the\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\n\nvar LONGEST_DUMMY_PHONE_NUMBER = (0, _AsYouTypeFormatterUtil.repeat)(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH); // A set of characters that, if found in a national prefix formatting rules, are an indicator to\n// us that we should separate the national prefix from the number when formatting.\n\nvar NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/; // Deprecated: Google has removed some formatting pattern related code from their repo.\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\n// Because this library supports generating custom metadata\n// some users may still be using old metadata so the relevant\n// code seems to stay until some next major version update.\n\nvar SUPPORT_LEGACY_FORMATTING_PATTERNS = true; // A pattern that is used to match character classes in regular expressions.\n// An example of a character class is \"[1-4]\".\n\nvar CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\[([^\\[\\]])*\\]/g;\n}; // Any digit in a regular expression that actually denotes a digit. For\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\n// (8 and 0) are standalone digits, but the rest are not.\n// Two look-aheads are needed because the number following \\\\d could be a\n// two-digit number, since the phone number can be as long as 15 digits.\n\n\nvar CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\d(?=[^,}][^,}])/g;\n}; // A regular expression that is used to determine if a `format` is\n// suitable to be used in the \"as you type formatter\".\n// A `format` is suitable when the resulting formatted number has\n// the same digits as the user has entered.\n//\n// In the simplest case, that would mean that the format\n// doesn't add any additional digits when formatting a number.\n// Google says that it also shouldn't add \"star\" (`*`) characters,\n// like it does in some Israeli formats.\n// Such basic format would only contain \"valid punctuation\"\n// and \"captured group\" identifiers ($1, $2, etc).\n//\n// An example of a format that adds additional digits:\n//\n// Country: `AR` (Argentina).\n// Format:\n// {\n//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\n//    \"leading_digits_patterns\": [\"91\"],\n//    \"national_prefix_formatting_rule\": \"0$1\",\n//    \"format\": \"$2 15-$3-$4\",\n//    \"international_format\": \"$1 $2 $3-$4\"\n// }\n//\n// In the format above, the `format` adds `15` to the digits when formatting a number.\n// A sidenote: this format actually is suitable because `national_prefix_for_parsing`\n// has previously removed `15` from a national number, so re-adding `15` in `format`\n// doesn't actually result in any extra digits added to user's input.\n// But verifying that would be a complex procedure, so the code chooses a simpler path:\n// it simply filters out all `format`s that contain anything but \"captured group\" ids.\n//\n// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's\n// `libphonenumber` code.\n//\n\n\nvar NON_ALTERING_FORMAT_REG_EXP = new RegExp('[' + _constants.VALID_PUNCTUATION + ']*' + // Google developers say:\n// \"We require that the first matching group is present in the\n//  output pattern to ensure no data is lost while formatting.\"\n'\\\\$1' + '[' + _constants.VALID_PUNCTUATION + ']*' + '(\\\\$\\\\d[' + _constants.VALID_PUNCTUATION + ']*)*' + '$'); // This is the minimum length of the leading digits of a phone number\n// to guarantee the first \"leading digits pattern\" for a phone number format\n// to be preemptive.\n\nvar MIN_LEADING_DIGITS_LENGTH = 3;\n\nvar AsYouTypeFormatter = /*#__PURE__*/function () {\n  function AsYouTypeFormatter(_ref) {\n    var state = _ref.state,\n        metadata = _ref.metadata;\n\n    _classCallCheck(this, AsYouTypeFormatter);\n\n    this.metadata = metadata;\n    this.resetFormat();\n  }\n\n  _createClass(AsYouTypeFormatter, [{\n    key: \"resetFormat\",\n    value: function resetFormat() {\n      this.chosenFormat = undefined;\n      this.template = undefined;\n      this.nationalNumberTemplate = undefined;\n      this.populatedNationalNumberTemplate = undefined;\n      this.populatedNationalNumberTemplatePosition = -1;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(numberingPlan, state) {\n      this.resetFormat();\n\n      if (numberingPlan) {\n        this.isNANP = numberingPlan.callingCode() === '1';\n        this.matchingFormats = numberingPlan.formats();\n\n        if (state.nationalSignificantNumber) {\n          this.narrowDownMatchingFormats(state);\n        }\n      } else {\n        this.isNANP = undefined;\n        this.matchingFormats = [];\n      }\n    }\n    /**\r\n     * Formats an updated phone number.\r\n     * @param  {string} nextDigits \u2014 Additional phone number digits.\r\n     * @param  {object} state \u2014\u00a0`AsYouType` state.\r\n     * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.\r\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(nextDigits, state) {\n      var _this = this;\n\n      // See if the phone number digits can be formatted as a complete phone number.\n      // If not, use the results from `formatNationalNumberWithNextDigits()`,\n      // which formats based on the chosen formatting pattern.\n      //\n      // Attempting to format complete phone number first is how it's done\n      // in Google's `libphonenumber`, so this library just follows it.\n      // Google's `libphonenumber` code doesn't explain in detail why does it\n      // attempt to format digits as a complete phone number\n      // instead of just going with a previoulsy (or newly) chosen `format`:\n      //\n      // \"Checks to see if there is an exact pattern match for these digits.\n      //  If so, we should use this instead of any other formatting template\n      //  whose leadingDigitsPattern also matches the input.\"\n      //\n      if ((0, _AsYouTypeFormatterComplete.canFormatCompleteNumber)(state.nationalSignificantNumber, this.metadata)) {\n        for (var _iterator = _createForOfIteratorHelperLoose(this.matchingFormats), _step; !(_step = _iterator()).done;) {\n          var format = _step.value;\n          var formattedCompleteNumber = (0, _AsYouTypeFormatterComplete[\"default\"])(state, format, {\n            metadata: this.metadata,\n            shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format) {\n              return _this.shouldTryNationalPrefixFormattingRule(format, {\n                international: state.international,\n                nationalPrefix: state.nationalPrefix\n              });\n            },\n            getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format) {\n              return _this.getSeparatorAfterNationalPrefix(format);\n            }\n          });\n\n          if (formattedCompleteNumber) {\n            this.resetFormat();\n            this.chosenFormat = format;\n            this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\d/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER), state);\n            this.populatedNationalNumberTemplate = formattedCompleteNumber; // With a new formatting template, the matched position\n            // using the old template needs to be reset.\n\n            this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);\n            return formattedCompleteNumber;\n          }\n        }\n      } // Format the digits as a partial (incomplete) phone number\n      // using the previously chosen formatting pattern (or a newly chosen one).\n\n\n      return this.formatNationalNumberWithNextDigits(nextDigits, state);\n    } // Formats the next phone number digits.\n\n  }, {\n    key: \"formatNationalNumberWithNextDigits\",\n    value: function formatNationalNumberWithNextDigits(nextDigits, state) {\n      var previouslyChosenFormat = this.chosenFormat; // Choose a format from the list of matching ones.\n\n      var newlyChosenFormat = this.chooseFormat(state);\n\n      if (newlyChosenFormat) {\n        if (newlyChosenFormat === previouslyChosenFormat) {\n          // If it can format the next (current) digits\n          // using the previously chosen phone number format\n          // then return the updated formatted number.\n          return this.formatNextNationalNumberDigits(nextDigits);\n        } else {\n          // If a more appropriate phone number format\n          // has been chosen for these \"leading digits\",\n          // then re-format the national phone number part\n          // using the newly selected format.\n          return this.formatNextNationalNumberDigits(state.getNationalDigits());\n        }\n      }\n    }\n  }, {\n    key: \"narrowDownMatchingFormats\",\n    value: function narrowDownMatchingFormats(_ref2) {\n      var _this2 = this;\n\n      var nationalSignificantNumber = _ref2.nationalSignificantNumber,\n          nationalPrefix = _ref2.nationalPrefix,\n          international = _ref2.international;\n      var leadingDigits = nationalSignificantNumber; // \"leading digits\" pattern list starts with a\n      // \"leading digits\" pattern fitting a maximum of 3 leading digits.\n      // So, after a user inputs 3 digits of a national (significant) phone number\n      // this national (significant) number can already be formatted.\n      // The next \"leading digits\" pattern is for 4 leading digits max,\n      // and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\n      // This implementation is different from Google's\n      // in that it searches for a fitting format\n      // even if the user has entered less than\n      // `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\n      // Because some leading digit patterns already match for a single first digit.\n\n      var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;\n\n      if (leadingDigitsPatternIndex < 0) {\n        leadingDigitsPatternIndex = 0;\n      }\n\n      this.matchingFormats = this.matchingFormats.filter(function (format) {\n        return _this2.formatSuits(format, international, nationalPrefix) && _this2.formatMatches(format, leadingDigits, leadingDigitsPatternIndex);\n      }); // If there was a phone number format chosen\n      // and it no longer holds given the new leading digits then reset it.\n      // The test for this `if` condition is marked as:\n      // \"Reset a chosen format when it no longer holds given the new leading digits\".\n      // To construct a valid test case for this one can find a country\n      // in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\n      // and yielding another format for 4 `<leadingDigits>` (Australia in this case).\n\n      if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\n        this.resetFormat();\n      }\n    }\n  }, {\n    key: \"formatSuits\",\n    value: function formatSuits(format, international, nationalPrefix) {\n      // When a prefix before a national (significant) number is\n      // simply a national prefix, then it's parsed as `this.nationalPrefix`.\n      // In more complex cases, a prefix before national (significant) number\n      // could include a national prefix as well as some \"capturing groups\",\n      // and in that case there's no info whether a national prefix has been parsed.\n      // If national prefix is not used when formatting a phone number\n      // using this format, but a national prefix has been entered by the user,\n      // and was extracted, then discard such phone number format.\n      // In Google's \"AsYouType\" formatter code, the equivalent would be this part:\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184\n      if (nationalPrefix && !format.usesNationalPrefix() && // !format.domesticCarrierCodeFormattingRule() &&\n      !format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\n        return false;\n      } // If national prefix is mandatory for this phone number format\n      // and there're no guarantees that a national prefix is present in user input\n      // then discard this phone number format as not suitable.\n      // In Google's \"AsYouType\" formatter code, the equivalent would be this part:\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193\n\n\n      if (!international && !nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"formatMatches\",\n    value: function formatMatches(format, leadingDigits, leadingDigitsPatternIndex) {\n      var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length; // If this format is not restricted to a certain\n      // leading digits pattern then it fits.\n      // The test case could be found by searching for \"leadingDigitsPatternsCount === 0\".\n\n      if (leadingDigitsPatternsCount === 0) {\n        return true;\n      } // Start narrowing down the list of possible formats based on the leading digits.\n      // (only previously matched formats take part in the narrowing down process)\n      // `leading_digits_patterns` start with 3 digits min\n      // and then go up from there one digit at a time.\n\n\n      leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);\n      var leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]; // Google imposes a requirement on the leading digits\n      // to be minimum 3 digits long in order to be eligible\n      // for checking those with a leading digits pattern.\n      //\n      // Since `leading_digits_patterns` start with 3 digits min,\n      // Google's original `libphonenumber` library only starts\n      // excluding any non-matching formats only when the\n      // national number entered so far is at least 3 digits long,\n      // otherwise format matching would give false negatives.\n      //\n      // For example, when the digits entered so far are `2`\n      // and the leading digits pattern is `21` \u2013\n      // it's quite obvious in this case that the format could be the one\n      // but due to the absence of further digits it would give false negative.\n      //\n      // Also, `leading_digits_patterns` doesn't always correspond to a single\n      // digits count. For example, `60|8` pattern would already match `8`\n      // but the `60` part would require having at least two leading digits,\n      // so the whole pattern would require inputting two digits first in order to\n      // decide on whether it matches the input, even when the input is \"80\".\n      //\n      // This library \u2014 `libphonenumber-js` \u2014 allows filtering by `leading_digits_patterns`\n      // even when there's only 1 or 2 digits of the national (significant) number.\n      // To do that, it uses a non-strict pattern matcher written specifically for that.\n      //\n\n      if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\n        // Before leading digits < 3 matching was implemented:\n        // return true\n        //\n        // After leading digits < 3 matching was implemented:\n        try {\n          return new _AsYouTypeFormatterPatternMatcher[\"default\"](leadingDigitsPattern).match(leadingDigits, {\n            allowOverflow: true\n          }) !== undefined;\n        } catch (error)\n        /* istanbul ignore next */\n        {\n          // There's a slight possibility that there could be some undiscovered bug\n          // in the pattern matcher code. Since the \"leading digits < 3 matching\"\n          // feature is not \"essential\" for operation, it can fall back to the old way\n          // in case of any issues rather than halting the application's execution.\n          console.error(error);\n          return true;\n        }\n      } // If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are\n      // available then use the usual regular expression matching.\n      //\n      // The whole pattern is wrapped in round brackets (`()`) because\n      // the pattern can use \"or\" operator (`|`) at the top level of the pattern.\n      //\n\n\n      return new RegExp(\"^(\".concat(leadingDigitsPattern, \")\")).test(leadingDigits);\n    }\n  }, {\n    key: \"getFormatFormat\",\n    value: function getFormatFormat(format, international) {\n      return international ? format.internationalFormat() : format.format();\n    }\n  }, {\n    key: \"chooseFormat\",\n    value: function chooseFormat(state) {\n      var _this3 = this;\n\n      var _loop = function _loop() {\n        var format = _step2.value;\n\n        // If this format is currently being used\n        // and is still suitable, then stick to it.\n        if (_this3.chosenFormat === format) {\n          return \"break\";\n        } // Sometimes, a formatting rule inserts additional digits in a phone number,\n        // and \"as you type\" formatter can't do that: it should only use the digits\n        // that the user has input.\n        //\n        // For example, in Argentina, there's a format for mobile phone numbers:\n        //\n        // {\n        //    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\n        //    \"leading_digits_patterns\": [\"91\"],\n        //    \"national_prefix_formatting_rule\": \"0$1\",\n        //    \"format\": \"$2 15-$3-$4\",\n        //    \"international_format\": \"$1 $2 $3-$4\"\n        // }\n        //\n        // In that format, `international_format` is used instead of `format`\n        // because `format` inserts `15` in the formatted number,\n        // and `AsYouType` formatter should only use the digits\n        // the user has actually input, without adding any extra digits.\n        // In this case, it wouldn't make a difference, because the `15`\n        // is first stripped when applying `national_prefix_for_parsing`\n        // and then re-added when using `format`, so in reality it doesn't\n        // add any new digits to the number, but to detect that, the code\n        // would have to be more complex: it would have to try formatting\n        // the digits using the format and then see if any digits have\n        // actually been added or removed, and then, every time a new digit\n        // is input, it should re-check whether the chosen format doesn't\n        // alter the digits.\n        //\n        // Google's code doesn't go that far, and so does this library:\n        // it simply requires that a `format` doesn't add any additonal\n        // digits to user's input.\n        //\n        // Also, people in general should move from inputting phone numbers\n        // in national format (possibly with national prefixes)\n        // and use international phone number format instead:\n        // it's a logical thing in the modern age of mobile phones,\n        // globalization and the internet.\n        //\n\n        /* istanbul ignore if */\n\n\n        if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format, state.international))) {\n          return \"continue\";\n        }\n\n        if (!_this3.createTemplateForFormat(format, state)) {\n          // Remove the format if it can't generate a template.\n          _this3.matchingFormats = _this3.matchingFormats.filter(function (_) {\n            return _ !== format;\n          });\n          return \"continue\";\n        }\n\n        _this3.chosenFormat = format;\n        return \"break\";\n      };\n\n      // When there are multiple available formats, the formatter uses the first\n      // format where a formatting template could be created.\n      //\n      // For some weird reason, `istanbul` says \"else path not taken\"\n      // for the `for of` line below. Supposedly that means that\n      // the loop doesn't ever go over the last element in the list.\n      // That's true because there always is `this.chosenFormat`\n      // when `this.matchingFormats` is non-empty.\n      // And, for some weird reason, it doesn't think that the case\n      // with empty `this.matchingFormats` qualifies for a valid \"else\" path.\n      // So simply muting this `istanbul` warning.\n      // It doesn't skip the contents of the `for of` loop,\n      // it just skips the `for of` line.\n      //\n\n      /* istanbul ignore next */\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done;) {\n        var _ret = _loop();\n\n        if (_ret === \"break\") break;\n        if (_ret === \"continue\") continue;\n      }\n\n      if (!this.chosenFormat) {\n        // No format matches the national (significant) phone number.\n        this.resetFormat();\n      }\n\n      return this.chosenFormat;\n    }\n  }, {\n    key: \"createTemplateForFormat\",\n    value: function createTemplateForFormat(format, state) {\n      // The formatter doesn't format numbers when numberPattern contains '|', e.g.\n      // (20|3)\\d{4}. In those cases we quickly return.\n      // (Though there's no such format in current metadata)\n\n      /* istanbul ignore if */\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\n        return;\n      } // Get formatting template for this phone number format\n\n\n      var template = this.getTemplateForFormat(format, state); // If the national number entered is too long\n      // for any phone number format, then abort.\n\n      if (template) {\n        this.setNationalNumberTemplate(template, state);\n        return true;\n      }\n    }\n  }, {\n    key: \"getSeparatorAfterNationalPrefix\",\n    value: function getSeparatorAfterNationalPrefix(format) {\n      // `US` metadata doesn't have a `national_prefix_formatting_rule`,\n      // so the `if` condition below doesn't apply to `US`,\n      // but in reality there shoudl be a separator\n      // between a national prefix and a national (significant) number.\n      // So `US` national prefix separator is a \"special\" \"hardcoded\" case.\n      if (this.isNANP) {\n        return ' ';\n      } // If a `format` has a `national_prefix_formatting_rule`\n      // and that rule has a separator after a national prefix,\n      // then it means that there should be a separator\n      // between a national prefix and a national (significant) number.\n\n\n      if (format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\n        return ' ';\n      } // At this point, there seems to be no clear evidence that\n      // there should be a separator between a national prefix\n      // and a national (significant) number. So don't insert one.\n\n\n      return '';\n    }\n  }, {\n    key: \"getInternationalPrefixBeforeCountryCallingCode\",\n    value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {\n      var IDDPrefix = _ref3.IDDPrefix,\n          missingPlus = _ref3.missingPlus;\n\n      if (IDDPrefix) {\n        return options && options.spacing === false ? IDDPrefix : IDDPrefix + ' ';\n      }\n\n      if (missingPlus) {\n        return '';\n      }\n\n      return '+';\n    }\n  }, {\n    key: \"getTemplate\",\n    value: function getTemplate(state) {\n      if (!this.template) {\n        return;\n      } // `this.template` holds the template for a \"complete\" phone number.\n      // The currently entered phone number is most likely not \"complete\",\n      // so trim all non-populated digits.\n\n\n      var index = -1;\n      var i = 0;\n      var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {\n        spacing: false\n      }) : '';\n\n      while (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {\n        index = this.template.indexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, index + 1);\n        i++;\n      }\n\n      return (0, _AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.template, index + 1);\n    }\n  }, {\n    key: \"setNationalNumberTemplate\",\n    value: function setNationalNumberTemplate(template, state) {\n      this.nationalNumberTemplate = template;\n      this.populatedNationalNumberTemplate = template; // With a new formatting template, the matched position\n      // using the old template needs to be reset.\n\n      this.populatedNationalNumberTemplatePosition = -1; // For convenience, the public `.template` property\n      // contains the whole international number\n      // if the phone number being input is international:\n      // 'x' for the '+' sign, 'x'es for the country phone code,\n      // a spacebar and then the template for the formatted national number.\n\n      if (state.international) {\n        this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\d\\+]/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER) + (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, state.callingCode.length) + ' ' + template;\n      } else {\n        this.template = template;\n      }\n    }\n    /**\r\n     * Generates formatting template for a national phone number,\r\n     * optionally containing a national prefix, for a format.\r\n     * @param  {Format} format\r\n     * @param  {string} nationalPrefix\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getTemplateForFormat\",\n    value: function getTemplateForFormat(format, _ref4) {\n      var nationalSignificantNumber = _ref4.nationalSignificantNumber,\n          international = _ref4.international,\n          nationalPrefix = _ref4.nationalPrefix,\n          complexPrefixBeforeNationalSignificantNumber = _ref4.complexPrefixBeforeNationalSignificantNumber;\n      var pattern = format.pattern();\n      /* istanbul ignore else */\n\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\n        pattern = pattern // Replace anything in the form of [..] with \\d\n        .replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d') // Replace any standalone digit (not the one in `{}`) with \\d\n        .replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d');\n      } // Generate a dummy national number (consisting of `9`s)\n      // that fits this format's `pattern`.\n      //\n      // This match will always succeed,\n      // because the \"longest dummy phone number\"\n      // has enough length to accomodate any possible\n      // national phone number format pattern.\n      //\n\n\n      var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]; // If the national number entered is too long\n      // for any phone number format, then abort.\n\n      if (nationalSignificantNumber.length > digits.length) {\n        return;\n      } // Get a formatting template which can be used to efficiently format\n      // a partial number where digits are added one by one.\n      // Below `strictPattern` is used for the\n      // regular expression (with `^` and `$`).\n      // This wasn't originally in Google's `libphonenumber`\n      // and I guess they don't really need it\n      // because they're not using \"templates\" to format phone numbers\n      // but I added `strictPattern` after encountering\n      // South Korean phone number formatting bug.\n      //\n      // Non-strict regular expression bug demonstration:\n      //\n      // this.nationalSignificantNumber : `111111111` (9 digits)\n      //\n      // pattern : (\\d{2})(\\d{3,4})(\\d{4})\n      // format : `$1 $2 $3`\n      // digits : `9999999999` (10 digits)\n      //\n      // '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\n      //\n      // template : xx xxxx xxxx\n      //\n      // But the correct template in this case is `xx xxx xxxx`.\n      // The template was generated incorrectly because of the\n      // `{3,4}` variability in the `pattern`.\n      //\n      // The fix is, if `this.nationalSignificantNumber` has already sufficient length\n      // to satisfy the `pattern` completely then `this.nationalSignificantNumber`\n      // is used instead of `digits`.\n\n\n      var strictPattern = new RegExp('^' + pattern + '$');\n      var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\\d/g, DUMMY_DIGIT); // If `this.nationalSignificantNumber` has already sufficient length\n      // to satisfy the `pattern` completely then use it\n      // instead of `digits`.\n\n      if (strictPattern.test(nationalNumberDummyDigits)) {\n        digits = nationalNumberDummyDigits;\n      }\n\n      var numberFormat = this.getFormatFormat(format, international);\n      var nationalPrefixIncludedInTemplate; // If a user did input a national prefix (and that's guaranteed),\n      // and if a `format` does have a national prefix formatting rule,\n      // then see if that national prefix formatting rule\n      // prepends exactly the same national prefix the user has input.\n      // If that's the case, then use the `format` with the national prefix formatting rule.\n      // Otherwise, use  the `format` without the national prefix formatting rule,\n      // and prepend a national prefix manually to it.\n\n      if (this.shouldTryNationalPrefixFormattingRule(format, {\n        international: international,\n        nationalPrefix: nationalPrefix\n      })) {\n        var numberFormatWithNationalPrefix = numberFormat.replace(_formatNationalNumberUsingFormat.FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()); // If `national_prefix_formatting_rule` of a `format` simply prepends\n        // national prefix at the start of a national (significant) number,\n        // then such formatting can be used with `AsYouType` formatter.\n        // There seems to be no `else` case: everywhere in metadata,\n        // national prefix formatting rule is national prefix + $1,\n        // or `($1)`, in which case such format isn't even considered\n        // when the user has input a national prefix.\n\n        /* istanbul ignore else */\n\n        if ((0, _parseDigits[\"default\"])(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + (0, _parseDigits[\"default\"])('$1')) {\n          numberFormat = numberFormatWithNationalPrefix;\n          nationalPrefixIncludedInTemplate = true; // Replace all digits of the national prefix in the formatting template\n          // with `DIGIT_PLACEHOLDER`s.\n\n          if (nationalPrefix) {\n            var i = nationalPrefix.length;\n\n            while (i > 0) {\n              numberFormat = numberFormat.replace(/\\d/, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);\n              i--;\n            }\n          }\n        }\n      } // Generate formatting template for this phone number format.\n\n\n      var template = digits // Format the dummy phone number according to the format.\n      .replace(new RegExp(pattern), numberFormat) // Replace each dummy digit with a DIGIT_PLACEHOLDER.\n      .replace(new RegExp(DUMMY_DIGIT, 'g'), _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER); // If a prefix of a national (significant) number is not as simple\n      // as just a basic national prefix, then just prepend such prefix\n      // before the national (significant) number, optionally spacing\n      // the two with a whitespace.\n\n      if (!nationalPrefixIncludedInTemplate) {\n        if (complexPrefixBeforeNationalSignificantNumber) {\n          // Prepend the prefix to the template manually.\n          template = (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, complexPrefixBeforeNationalSignificantNumber.length) + ' ' + template;\n        } else if (nationalPrefix) {\n          // Prepend national prefix to the template manually.\n          template = (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + template;\n        }\n      }\n\n      if (international) {\n        template = (0, _applyInternationalSeparatorStyle[\"default\"])(template);\n      }\n\n      return template;\n    }\n  }, {\n    key: \"formatNextNationalNumberDigits\",\n    value: function formatNextNationalNumberDigits(digits) {\n      var result = (0, _AsYouTypeFormatterUtil.populateTemplateWithDigits)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);\n\n      if (!result) {\n        // Reset the format.\n        this.resetFormat();\n        return;\n      }\n\n      this.populatedNationalNumberTemplate = result[0];\n      this.populatedNationalNumberTemplatePosition = result[1]; // Return the formatted phone number so far.\n\n      return (0, _AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1); // The old way which was good for `input-format` but is not so good\n      // for `react-phone-number-input`'s default input (`InputBasic`).\n      // return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\n      // \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\n    }\n  }, {\n    key: \"shouldTryNationalPrefixFormattingRule\",\n    value: function shouldTryNationalPrefixFormattingRule(format, _ref5) {\n      var international = _ref5.international,\n          nationalPrefix = _ref5.nationalPrefix;\n\n      if (format.nationalPrefixFormattingRule()) {\n        // In some countries, `national_prefix_formatting_rule` is `($1)`,\n        // so it applies even if the user hasn't input a national prefix.\n        // `format.usesNationalPrefix()` detects such cases.\n        var usesNationalPrefix = format.usesNationalPrefix();\n\n        if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) {\n          return true;\n        }\n      }\n    }\n  }]);\n\n  return AsYouTypeFormatter;\n}();\n\nexports[\"default\"] = AsYouTypeFormatter;\n//# sourceMappingURL=AsYouTypeFormatter.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","_typeof","obj","Symbol","iterator","constructor","prototype","_interopRequireDefault","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","_createForOfIteratorHelperLoose","o","allowArrayLike","it","next","call","bind","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","minLen","_arrayLikeToArray","n","Object","toString","slice","name","from","test","arr","len","arr2","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","Constructor","protoProps","staticProps","get","_AsYouTypeFormatterUtil","DIGIT_PLACEHOLDER","_AsYouTypeFormatterComplete","_interopRequireWildcard","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","hasOwnProperty","desc","set","_AsYouTypeFormatterPatternMatcher","_parseDigits","_formatNationalNumberUsingFormat","_constants","_applyInternationalSeparatorStyle","LONGEST_DUMMY_PHONE_NUMBER","repeat","DUMMY_DIGIT","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","NATIONAL_PREFIX_SEPARATORS_PATTERN","NON_ALTERING_FORMAT_REG_EXP","RegExp","VALID_PUNCTUATION","AsYouTypeFormatter","_ref","metadata","instance","resetFormat","populatedNationalNumberTemplate","nationalNumberTemplate","template","chosenFormat","undefined","populatedNationalNumberTemplatePosition","reset","numberingPlan","state","isNANP","callingCode","matchingFormats","formats","nationalSignificantNumber","narrowDownMatchingFormats","format","nextDigits","_this","canFormatCompleteNumber","_iterator","_step","formattedCompleteNumber","shouldTryNationalPrefixFormattingRule","international","nationalPrefix","getSeparatorAfterNationalPrefix","setNationalNumberTemplate","replace","lastIndexOf","formatNationalNumberWithNextDigits","previouslyChosenFormat","newlyChosenFormat","chooseFormat","formatNextNationalNumberDigits","getNationalDigits","_ref2","_this2","leadingDigits","leadingDigitsPatternIndex","MIN_LEADING_DIGITS_LENGTH","filter","formatSuits","formatMatches","indexOf","usesNationalPrefix","nationalPrefixIsOptionalWhenFormattingInNationalFormat","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","leadingDigitsPatternsCount","leadingDigitsPatterns","Math","min","leadingDigitsPattern","match","allowOverflow","error","console","concat","getFormatFormat","internationalFormat","_this3","_loop","_step2","createTemplateForFormat","_","_iterator2","_ret","pattern","getTemplateForFormat","nationalPrefixFormattingRule","getInternationalPrefixBeforeCountryCallingCode","_ref3","options","IDDPrefix","spacing","missingPlus","getTemplate","index","internationalPrefix","getDigitsWithoutInternationalPrefix","cutAndStripNonPairedParens","_ref4","complexPrefixBeforeNationalSignificantNumber","digits","strictPattern","nationalNumberDummyDigits","numberFormat","numberFormatWithNationalPrefix","FIRST_GROUP_PATTERN","nationalPrefixIncludedInTemplate","result","populateTemplateWithDigits","_ref5"]
}
