{
"version":3,
"file":"module$node_modules$libphonenumber_js$build$AsYouTypeParser.js",
"lineCount":211,
"mappings":"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",
"sources":["node_modules/libphonenumber-js/build/AsYouTypeParser.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$libphonenumber_js$build$AsYouTypeParser\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nexports.extractFormattedDigitsAndPlus = extractFormattedDigitsAndPlus;\n\nvar _extractCountryCallingCode2 = _interopRequireDefault(require(\"./helpers/extractCountryCallingCode.js\"));\n\nvar _extractCountryCallingCodeFromInternationalNumberWithoutPlusSign = _interopRequireDefault(require(\"./helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js\"));\n\nvar _extractNationalNumberFromPossiblyIncompleteNumber = _interopRequireDefault(require(\"./helpers/extractNationalNumberFromPossiblyIncompleteNumber.js\"));\n\nvar _stripIddPrefix = _interopRequireDefault(require(\"./helpers/stripIddPrefix.js\"));\n\nvar _parseDigits = _interopRequireDefault(require(\"./helpers/parseDigits.js\"));\n\nvar _constants = require(\"./constants.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART = '[' + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + ']+';\nvar VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i');\nvar VALID_FORMATTED_PHONE_NUMBER_PART = '(?:' + '[' + _constants.PLUS_CHARS + ']' + '[' + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + ']*' + '|' + '[' + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + ']+' + ')';\nvar AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp('[^' + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + ']+' + '.*' + '$'); // Tests whether `national_prefix_for_parsing` could match\n// different national prefixes.\n// Matches anything that's not a digit or a square bracket.\n\nvar COMPLEX_NATIONAL_PREFIX = /[^\\d\\[\\]]/;\n\nvar AsYouTypeParser = /*#__PURE__*/function () {\n  function AsYouTypeParser(_ref) {\n    var defaultCountry = _ref.defaultCountry,\n        defaultCallingCode = _ref.defaultCallingCode,\n        metadata = _ref.metadata,\n        onNationalSignificantNumberChange = _ref.onNationalSignificantNumberChange;\n\n    _classCallCheck(this, AsYouTypeParser);\n\n    this.defaultCountry = defaultCountry;\n    this.defaultCallingCode = defaultCallingCode;\n    this.metadata = metadata;\n    this.onNationalSignificantNumberChange = onNationalSignificantNumberChange;\n  }\n\n  _createClass(AsYouTypeParser, [{\n    key: \"input\",\n    value: function input(text, state) {\n      var _extractFormattedDigi = extractFormattedDigitsAndPlus(text),\n          _extractFormattedDigi2 = _slicedToArray(_extractFormattedDigi, 2),\n          formattedDigits = _extractFormattedDigi2[0],\n          hasPlus = _extractFormattedDigi2[1];\n\n      var digits = (0, _parseDigits[\"default\"])(formattedDigits); // Checks for a special case: just a leading `+` has been entered.\n\n      var justLeadingPlus;\n\n      if (hasPlus) {\n        if (!state.digits) {\n          state.startInternationalNumber();\n\n          if (!digits) {\n            justLeadingPlus = true;\n          }\n        }\n      }\n\n      if (digits) {\n        this.inputDigits(digits, state);\n      }\n\n      return {\n        digits: digits,\n        justLeadingPlus: justLeadingPlus\n      };\n    }\n    /**\r\n     * Inputs \"next\" phone number digits.\r\n     * @param  {string} digits\r\n     * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n     */\n\n  }, {\n    key: \"inputDigits\",\n    value: function inputDigits(nextDigits, state) {\n      var digits = state.digits;\n      var hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3; // Append phone number digits.\n\n      state.appendDigits(nextDigits); // Attempt to extract IDD prefix:\n      // Some users input their phone number in international format,\n      // but in an \"out-of-country\" dialing format instead of using the leading `+`.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/185\n      // Detect such numbers as soon as there're at least 3 digits.\n      // Google's library attempts to extract IDD prefix at 3 digits,\n      // so this library just copies that behavior.\n      // I guess that's because the most commot IDD prefixes are\n      // `00` (Europe) and `011` (US).\n      // There exist really long IDD prefixes too:\n      // for example, in Australia the default IDD prefix is `0011`,\n      // and it could even be as long as `14880011`.\n      // An IDD prefix is extracted here, and then every time when\n      // there's a new digit and the number couldn't be formatted.\n\n      if (hasReceivedThreeLeadingDigits) {\n        this.extractIddPrefix(state);\n      }\n\n      if (this.isWaitingForCountryCallingCode(state)) {\n        if (!this.extractCountryCallingCode(state)) {\n          return;\n        }\n      } else {\n        state.appendNationalSignificantNumberDigits(nextDigits);\n      } // If a phone number is being input in international format,\n      // then it's not valid for it to have a national prefix.\n      // Still, some people incorrectly input such numbers with a national prefix.\n      // In such cases, only attempt to strip a national prefix if the number becomes too long.\n      // (but that is done later, not here)\n\n\n      if (!state.international) {\n        if (!this.hasExtractedNationalSignificantNumber) {\n          this.extractNationalSignificantNumber(state.getNationalDigits(), function (stateUpdate) {\n            return state.update(stateUpdate);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"isWaitingForCountryCallingCode\",\n    value: function isWaitingForCountryCallingCode(_ref2) {\n      var international = _ref2.international,\n          callingCode = _ref2.callingCode;\n      return international && !callingCode;\n    } // Extracts a country calling code from a number\n    // being entered in internatonal format.\n\n  }, {\n    key: \"extractCountryCallingCode\",\n    value: function extractCountryCallingCode(state) {\n      var _extractCountryCallin = (0, _extractCountryCallingCode2[\"default\"])('+' + state.getDigitsWithoutInternationalPrefix(), this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),\n          countryCallingCode = _extractCountryCallin.countryCallingCode,\n          number = _extractCountryCallin.number;\n\n      if (countryCallingCode) {\n        state.setCallingCode(countryCallingCode);\n        state.update({\n          nationalSignificantNumber: number\n        });\n        return true;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(numberingPlan) {\n      if (numberingPlan) {\n        this.hasSelectedNumberingPlan = true;\n\n        var nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing();\n\n        this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing);\n      } else {\n        this.hasSelectedNumberingPlan = undefined;\n        this.couldPossiblyExtractAnotherNationalSignificantNumber = undefined;\n      }\n    }\n    /**\r\n     * Extracts a national (significant) number from user input.\r\n     * Google's library is different in that it only applies `national_prefix_for_parsing`\r\n     * and doesn't apply `national_prefix_transform_rule` after that.\r\n     * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539\r\n     * @return {boolean} [extracted]\r\n     */\n\n  }, {\n    key: \"extractNationalSignificantNumber\",\n    value: function extractNationalSignificantNumber(nationalDigits, setState) {\n      if (!this.hasSelectedNumberingPlan) {\n        return;\n      }\n\n      var _extractNationalNumbe = (0, _extractNationalNumberFromPossiblyIncompleteNumber[\"default\"])(nationalDigits, this.metadata),\n          nationalPrefix = _extractNationalNumbe.nationalPrefix,\n          nationalNumber = _extractNationalNumbe.nationalNumber,\n          carrierCode = _extractNationalNumbe.carrierCode;\n\n      if (nationalNumber === nationalDigits) {\n        return;\n      }\n\n      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);\n      return true;\n    }\n    /**\r\n     * In Google's code this function is called \"attempt to extract longer NDD\".\r\n     * \"Some national prefixes are a substring of others\", they say.\r\n     * @return {boolean} [result] \u2014 Returns `true` if extracting a national prefix produced different results from what they were.\r\n     */\n\n  }, {\n    key: \"extractAnotherNationalSignificantNumber\",\n    value: function extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {\n      if (!this.hasExtractedNationalSignificantNumber) {\n        return this.extractNationalSignificantNumber(nationalDigits, setState);\n      }\n\n      if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {\n        return;\n      }\n\n      var _extractNationalNumbe2 = (0, _extractNationalNumberFromPossiblyIncompleteNumber[\"default\"])(nationalDigits, this.metadata),\n          nationalPrefix = _extractNationalNumbe2.nationalPrefix,\n          nationalNumber = _extractNationalNumbe2.nationalNumber,\n          carrierCode = _extractNationalNumbe2.carrierCode; // If a national prefix has been extracted previously,\n      // then it's always extracted as additional digits are added.\n      // That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`\n      // doesn't do anything different from what it currently does.\n      // So, just in case, here's this check, though it doesn't occur.\n\n      /* istanbul ignore if */\n\n\n      if (nationalNumber === prevNationalSignificantNumber) {\n        return;\n      }\n\n      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);\n      return true;\n    }\n  }, {\n    key: \"onExtractedNationalNumber\",\n    value: function onExtractedNationalNumber(nationalPrefix, carrierCode, nationalSignificantNumber, nationalDigits, setState) {\n      var complexPrefixBeforeNationalSignificantNumber;\n      var nationalSignificantNumberMatchesInput; // This check also works with empty `this.nationalSignificantNumber`.\n\n      var nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber); // If the extracted national (significant) number is the\n      // last substring of the `digits`, then it means that it hasn't been altered:\n      // no digits have been removed from the national (significant) number\n      // while applying `national_prefix_transform_rule`.\n      // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n\n      if (nationalSignificantNumberIndex >= 0 && nationalSignificantNumberIndex === nationalDigits.length - nationalSignificantNumber.length) {\n        nationalSignificantNumberMatchesInput = true; // If a prefix of a national (significant) number is not as simple\n        // as just a basic national prefix, then such prefix is stored in\n        // `this.complexPrefixBeforeNationalSignificantNumber` property and will be\n        // prepended \"as is\" to the national (significant) number to produce\n        // a formatted result.\n\n        var prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex); // `prefixBeforeNationalNumber` is always non-empty,\n        // because `onExtractedNationalNumber()` isn't called\n        // when a national (significant) number hasn't been actually \"extracted\":\n        // when a national (significant) number is equal to the national part of `digits`,\n        // then `onExtractedNationalNumber()` doesn't get called.\n\n        if (prefixBeforeNationalNumber !== nationalPrefix) {\n          complexPrefixBeforeNationalSignificantNumber = prefixBeforeNationalNumber;\n        }\n      }\n\n      setState({\n        nationalPrefix: nationalPrefix,\n        carrierCode: carrierCode,\n        nationalSignificantNumber: nationalSignificantNumber,\n        nationalSignificantNumberMatchesInput: nationalSignificantNumberMatchesInput,\n        complexPrefixBeforeNationalSignificantNumber: complexPrefixBeforeNationalSignificantNumber\n      }); // `onExtractedNationalNumber()` is only called when\n      // the national (significant) number actually did change.\n\n      this.hasExtractedNationalSignificantNumber = true;\n      this.onNationalSignificantNumberChange();\n    }\n  }, {\n    key: \"reExtractNationalSignificantNumber\",\n    value: function reExtractNationalSignificantNumber(state) {\n      // Attempt to extract a national prefix.\n      //\n      // Some people incorrectly input national prefix\n      // in an international phone number.\n      // For example, some people write British phone numbers as `+44(0)...`.\n      //\n      // Also, in some rare cases, it is valid for a national prefix\n      // to be a part of an international phone number.\n      // For example, mobile phone numbers in Mexico are supposed to be\n      // dialled internationally using a `1` national prefix,\n      // so the national prefix will be part of an international number.\n      //\n      // Quote from:\n      // https://www.mexperience.com/dialing-cell-phones-in-mexico/\n      //\n      // \"Dialing a Mexican cell phone from abroad\n      // When you are calling a cell phone number in Mexico from outside Mexico,\n      // it\u2019s necessary to dial an additional \u201c1\u201d after Mexico\u2019s country code\n      // (which is \u201c52\u201d) and before the area code.\n      // You also ignore the 045, and simply dial the area code and the\n      // cell phone\u2019s number.\n      //\n      // If you don\u2019t add the \u201c1\u201d, you\u2019ll receive a recorded announcement\n      // asking you to redial using it.\n      //\n      // For example, if you are calling from the USA to a cell phone\n      // in Mexico City, you would dial +52 \u2013 1 \u2013 55 \u2013 1234 5678.\n      // (Note that this is different to calling a land line in Mexico City\n      // from abroad, where the number dialed would be +52 \u2013 55 \u2013 1234 5678)\".\n      //\n      // Google's demo output:\n      // https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&country=MX\n      //\n      if (this.extractAnotherNationalSignificantNumber(state.getNationalDigits(), state.nationalSignificantNumber, function (stateUpdate) {\n        return state.update(stateUpdate);\n      })) {\n        return true;\n      } // If no format matches the phone number, then it could be\n      // \"a really long IDD\" (quote from a comment in Google's library).\n      // An IDD prefix is first extracted when the user has entered at least 3 digits,\n      // and then here \u2014 every time when there's a new digit and the number\n      // couldn't be formatted.\n      // For example, in Australia the default IDD prefix is `0011`,\n      // and it could even be as long as `14880011`.\n      //\n      // Could also check `!hasReceivedThreeLeadingDigits` here\n      // to filter out the case when this check duplicates the one\n      // already performed when there're 3 leading digits,\n      // but it's not a big deal, and in most cases there\n      // will be a suitable `format` when there're 3 leading digits.\n      //\n\n\n      if (this.extractIddPrefix(state)) {\n        this.extractCallingCodeAndNationalSignificantNumber(state);\n        return true;\n      } // Google's AsYouType formatter supports sort of an \"autocorrection\" feature\n      // when it \"autocorrects\" numbers that have been input for a country\n      // with that country's calling code.\n      // Such \"autocorrection\" feature looks weird, but different people have been requesting it:\n      // https://github.com/catamphetamine/libphonenumber-js/issues/376\n      // https://github.com/catamphetamine/libphonenumber-js/issues/375\n      // https://github.com/catamphetamine/libphonenumber-js/issues/316\n\n\n      if (this.fixMissingPlus(state)) {\n        this.extractCallingCodeAndNationalSignificantNumber(state);\n        return true;\n      }\n    }\n  }, {\n    key: \"extractIddPrefix\",\n    value: function extractIddPrefix(state) {\n      // An IDD prefix can't be present in a number written with a `+`.\n      // Also, don't re-extract an IDD prefix if has already been extracted.\n      var international = state.international,\n          IDDPrefix = state.IDDPrefix,\n          digits = state.digits,\n          nationalSignificantNumber = state.nationalSignificantNumber;\n\n      if (international || IDDPrefix) {\n        return;\n      } // Some users input their phone number in \"out-of-country\"\n      // dialing format instead of using the leading `+`.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/185\n      // Detect such numbers.\n\n\n      var numberWithoutIDD = (0, _stripIddPrefix[\"default\"])(digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);\n\n      if (numberWithoutIDD !== undefined && numberWithoutIDD !== digits) {\n        // If an IDD prefix was stripped then convert the IDD-prefixed number\n        // to international number for subsequent parsing.\n        state.update({\n          IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)\n        });\n        this.startInternationalNumber(state, {\n          country: undefined,\n          callingCode: undefined\n        });\n        return true;\n      }\n    }\n  }, {\n    key: \"fixMissingPlus\",\n    value: function fixMissingPlus(state) {\n      if (!state.international) {\n        var _extractCountryCallin2 = (0, _extractCountryCallingCodeFromInternationalNumberWithoutPlusSign[\"default\"])(state.digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),\n            newCallingCode = _extractCountryCallin2.countryCallingCode,\n            number = _extractCountryCallin2.number;\n\n        if (newCallingCode) {\n          state.update({\n            missingPlus: true\n          });\n          this.startInternationalNumber(state, {\n            country: state.country,\n            callingCode: newCallingCode\n          });\n          return true;\n        }\n      }\n    }\n  }, {\n    key: \"startInternationalNumber\",\n    value: function startInternationalNumber(state, _ref3) {\n      var country = _ref3.country,\n          callingCode = _ref3.callingCode;\n      state.startInternationalNumber(country, callingCode); // If a national (significant) number has been extracted before, reset it.\n\n      if (state.nationalSignificantNumber) {\n        state.resetNationalSignificantNumber();\n        this.onNationalSignificantNumberChange();\n        this.hasExtractedNationalSignificantNumber = undefined;\n      }\n    }\n  }, {\n    key: \"extractCallingCodeAndNationalSignificantNumber\",\n    value: function extractCallingCodeAndNationalSignificantNumber(state) {\n      if (this.extractCountryCallingCode(state)) {\n        // `this.extractCallingCode()` is currently called when the number\n        // couldn't be formatted during the standard procedure.\n        // Normally, the national prefix would be re-extracted\n        // for an international number if such number couldn't be formatted,\n        // but since it's already not able to be formatted,\n        // there won't be yet another retry, so also extract national prefix here.\n        this.extractNationalSignificantNumber(state.getNationalDigits(), function (stateUpdate) {\n          return state.update(stateUpdate);\n        });\n      }\n    }\n  }]);\n\n  return AsYouTypeParser;\n}();\n/**\r\n * Extracts formatted phone number from text (if there's any).\r\n * @param  {string} text\r\n * @return {string} [formattedPhoneNumber]\r\n */\n\n\nexports[\"default\"] = AsYouTypeParser;\n\nfunction extractFormattedPhoneNumber(text) {\n  // Attempt to extract a possible number from the string passed in.\n  var startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART);\n\n  if (startsAt < 0) {\n    return;\n  } // Trim everything to the left of the phone number.\n\n\n  text = text.slice(startsAt); // Trim the `+`.\n\n  var hasPlus;\n\n  if (text[0] === '+') {\n    hasPlus = true;\n    text = text.slice('+'.length);\n  } // Trim everything to the right of the phone number.\n\n\n  text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, ''); // Re-add the previously trimmed `+`.\n\n  if (hasPlus) {\n    text = '+' + text;\n  }\n\n  return text;\n}\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\n\n\nfunction _extractFormattedDigitsAndPlus(text) {\n  // Extract a formatted phone number part from text.\n  var extractedNumber = extractFormattedPhoneNumber(text) || ''; // Trim a `+`.\n\n  if (extractedNumber[0] === '+') {\n    return [extractedNumber.slice('+'.length), true];\n  }\n\n  return [extractedNumber];\n}\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\n\n\nfunction extractFormattedDigitsAndPlus(text) {\n  var _extractFormattedDigi3 = _extractFormattedDigitsAndPlus(text),\n      _extractFormattedDigi4 = _slicedToArray(_extractFormattedDigi3, 2),\n      formattedDigits = _extractFormattedDigi4[0],\n      hasPlus = _extractFormattedDigi4[1]; // If the extracted phone number part\n  // can possibly be a part of some valid phone number\n  // then parse phone number characters from a formatted phone number.\n\n\n  if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {\n    formattedDigits = '';\n  }\n\n  return [formattedDigits, hasPlus];\n}\n//# sourceMappingURL=AsYouTypeParser.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","obj","__esModule","_slicedToArray","arr","i","Array","isArray","_i","Symbol","iterator","_arr","_n","_d","_s","call","done","next","push","value","length","err","_e","o","_arrayLikeToArray","minLen","n","Object","prototype","toString","slice","constructor","name","from","test","TypeError","len","arr2","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","Constructor","protoProps","staticProps","extractFormattedDigitsAndPlus","text","startsAt","search","VALID_FORMATTED_PHONE_NUMBER_PART","hasPlus","replace","AFTER_PHONE_NUMBER_DIGITS_END_PATTERN","extractedNumber","_extractFormattedDigi4","_extractFormattedDigi3","formattedDigits","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN","_extractCountryCallingCode2","_extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","_extractNationalNumberFromPossiblyIncompleteNumber","_stripIddPrefix","_parseDigits","_constants","RegExp","VALID_PUNCTUATION","VALID_DIGITS","PLUS_CHARS","COMPLEX_NATIONAL_PREFIX","AsYouTypeParser","_ref","defaultCountry","defaultCallingCode","metadata","onNationalSignificantNumberChange","instance","input","state","_extractFormattedDigi","_extractFormattedDigi2","digits","justLeadingPlus","startInternationalNumber","inputDigits","nextDigits","hasReceivedThreeLeadingDigits","appendDigits","extractIddPrefix","isWaitingForCountryCallingCode","extractCountryCallingCode","appendNationalSignificantNumberDigits","international","hasExtractedNationalSignificantNumber","extractNationalSignificantNumber","getNationalDigits","stateUpdate","update","_ref2","callingCode","_extractCountryCallin","getDigitsWithoutInternationalPrefix","countryCallingCode","number","setCallingCode","nationalSignificantNumber","reset","numberingPlan","hasSelectedNumberingPlan","couldPossiblyExtractAnotherNationalSignificantNumber","nationalPrefixForParsing","_nationalPrefixForParsing","undefined","nationalDigits","setState","_extractNationalNumbe","nationalNumber","onExtractedNationalNumber","nationalPrefix","carrierCode","extractAnotherNationalSignificantNumber","prevNationalSignificantNumber","_extractNationalNumbe2","complexPrefixBeforeNationalSignificantNumber","nationalSignificantNumberIndex","lastIndexOf","nationalSignificantNumberMatchesInput","prefixBeforeNationalNumber","reExtractNationalSignificantNumber","fixMissingPlus","extractCallingCodeAndNationalSignificantNumber","IDDPrefix","numberWithoutIDD","country","newCallingCode","_extractCountryCallin2","missingPlus","_ref3","resetNationalSignificantNumber"]
}
