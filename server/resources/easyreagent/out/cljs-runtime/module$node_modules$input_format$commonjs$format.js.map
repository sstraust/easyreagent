{
"version":3,
"file":"module$node_modules$input_format$commonjs$format.js",
"lineCount":35,
"mappings":"AAAAA,cAAA,CAAA,gDAAA,GAAqE,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAG7GC,QAAOC,CAAAA,cAAP,CAAsBF,OAAtB,EAA+B,YAA/B,EAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGAH,SAAA,CAAQ,SAAR,CAAA,GAsCAI,QAAe,CAACD,KAAD,EAAQE,KAAR,EAAeC,SAAf,CAA0B;AACd,YAAzB,KAAI,MAAOA,UAAX,KACEA,SADF,GACc,GAAIC,kBAAA,CAAmB,SAAnB,CAAJ,EAAmCD,SAAnC,CADd;AADuC,QAKnCE,OAAOF,SAAA,CAAUH,KAAV,CAAPK,IAA2B,EALQ;AAMnCC,aAAAA,GAAOD,IAAKC,CAAAA,IAAZA;AACAC,QAAAA,GAAWF,IAAKE,CAAAA,QAAhBA;AAESC,QAAAA,EAAb,KAAIF,SAAJ,KACEA,SADF,GACSN,KADT;AAIA,QAAIO,IAAJ;AACE,UAAcC,IAAAA,EAAd,KAAIN,KAAJ;AACEA,aAAA,GAAQI,SAAKG,CAAAA,MAAb;AADF,YAEO;AACDC,aAAAA,GAAQ,CAARA;AAIJ,aAHA,IAAIC,QAAQ,CAAA,CAAZ,EACIC,sCAAsC,CAAC,CAE3C,EAAOF,KAAP,GAAeJ,SAAKG,CAAAA,MAApB,IAA8BC,KAA9B,GAAsCH,IAASE,CAAAA,MAA/C,CAAA,CAAuD;AAErD,cAAIH,SAAA,CAAKI,KAAL,CAAJ,KAAoBH,IAAA,CAASG,KAAT,CAApB,CAAqC;AACnC,gBAAc,CAAd,KAAIR,KAAJ,CAAiB;AACfS,mBAAA,GAAQ,CAAA,CAAR;AACAT,mBAAA,GAAQQ,KAAR;AACA;AAHe;AAMjBE,+CAAA,GAAsCF,KAAtC;AACAR,iBAAA,EAAA;AARmC;AAWrCQ,eAAA,EAAA;AAbqD;AAkBlDC,aAAL,KACET,KADF,GACUU,mCADV,GACgD,CADhD;AAvBK;AAHT;AAgCA,WAAO,CACLN,KAAMA,SADD,EAEEJ,KAFF,CAAP;AA7CuC,GAtCzC;AAEA,MAAIE,qBAEJS,QAA+B,CAACC,GAAD,CAAM;AAAE,WAAOA,GAAA,IAAOA,GAAIC,CAAAA,UAAX,GAAwBD,GAAxB,GAA8B,CAAE,UAAWA,GAAb,CAArC;AAAF,GAFZ,CAAuBnB,OAAA,CAAQ,6DAAR,CAAvB,CAAzB;AAR6G,CAA7G;;",
"sources":["node_modules/input-format/commonjs/format.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$input_format$commonjs$format\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = format;\n\nvar _templateFormatter = _interopRequireDefault(require(\"./templateFormatter.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// Formats `value` value preserving `caret` at the same character.\n//\n// `{ value, caret }` attribute is the result of `parse()` function call.\n//\n// Returns `{ text, caret }` where the new `caret` is the caret position\n// inside `text` text corresponding to the original `caret` position inside `value`.\n//\n// `formatter(value)` is a function returning `{ text, template }`.\n//\n// `text` is the `value` value formatted using `template`.\n// It may either cut off the non-filled right part of the `template`\n// or it may fill the non-filled character placeholders\n// in the right part of the `template` with `spacer`\n// which is a space (' ') character by default.\n//\n// `template` is the template used to format the `value`.\n// It can be either a full-length template or a partial template.\n//\n// `formatter` can also be a string \u2014 a `template`\n// where character placeholders are denoted by 'x'es.\n// In this case `formatter` function is automatically created.\n//\n// Example:\n//\n// `value` is '880',\n// `caret` is `2` (before the first `0`)\n//\n// `formatter` is `'880' =>\n//   { text: '8 (80 )', template: 'x (xxx) xxx-xx-xx' }`\n//\n// The result is `{ text: '8 (80 )', caret: 4 }`.\n//\nfunction format(value, caret, formatter) {\n  if (typeof formatter === 'string') {\n    formatter = (0, _templateFormatter[\"default\"])(formatter);\n  }\n\n  var _ref = formatter(value) || {},\n      text = _ref.text,\n      template = _ref.template;\n\n  if (text === undefined) {\n    text = value;\n  }\n\n  if (template) {\n    if (caret === undefined) {\n      caret = text.length;\n    } else {\n      var index = 0;\n      var found = false;\n      var possibly_last_input_character_index = -1;\n\n      while (index < text.length && index < template.length) {\n        // Character placeholder found\n        if (text[index] !== template[index]) {\n          if (caret === 0) {\n            found = true;\n            caret = index;\n            break;\n          }\n\n          possibly_last_input_character_index = index;\n          caret--;\n        }\n\n        index++;\n      } // If the caret was positioned after last input character,\n      // then the text caret index is just after the last input character.\n\n\n      if (!found) {\n        caret = possibly_last_input_character_index + 1;\n      }\n    }\n  }\n\n  return {\n    text: text,\n    caret: caret\n  };\n}\n//# sourceMappingURL=format.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","format","caret","formatter","_templateFormatter","_ref","text","template","undefined","length","index","found","possibly_last_input_character_index","_interopRequireDefault","obj","__esModule"]
}
