shadow$provide.module$node_modules$libphonenumber_js$build$PhoneNumberMatcher = function(global, require, module, exports) {
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _getRequireWildcardCache(nodeInterop) {
    if ("function" !== typeof WeakMap) {
      return null;
    }
    var cacheBabelInterop = new WeakMap(), cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default":obj};
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = "undefined" !== typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
    if (it) {
      return (it = it.call(o)).next.bind(it);
    }
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
      it && (o = it);
      var i = 0;
      return function() {
        return i >= o.length ? {done:!0} : {done:!1, value:o[i++]};
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (o) {
      if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen);
      }
      var n = Object.prototype.toString.call(o).slice(8, -1);
      "Object" === n && o.constructor && (n = o.constructor.name);
      if ("Map" === n || "Set" === n) {
        return Array.from(o);
      }
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen);
      }
    }
  }
  function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
      len = arr.length;
    }
    for (var i = 0, arr2 = Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || !1;
      descriptor.configurable = !0;
      "value" in descriptor && (descriptor.writable = !0);
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    protoProps && _defineProperties(Constructor.prototype, protoProps);
    staticProps && _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {writable:!1});
    return Constructor;
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports["default"] = void 0;
  _interopRequireDefault(require("module$node_modules$libphonenumber_js$build$PhoneNumber"));
  module = require("module$node_modules$libphonenumber_js$build$constants");
  var _createExtensionPattern = _interopRequireDefault(require("module$node_modules$libphonenumber_js$build$helpers$extension$createExtensionPattern")), _RegExpCache = _interopRequireDefault(require("module$node_modules$libphonenumber_js$build$findNumbers$RegExpCache")), _util = require("module$node_modules$libphonenumber_js$build$findNumbers$util");
  global = require("module$node_modules$libphonenumber_js$build$findNumbers$utf_8");
  var _Leniency = _interopRequireDefault(require("module$node_modules$libphonenumber_js$build$findNumbers$Leniency")), _parsePreCandidate = _interopRequireDefault(require("module$node_modules$libphonenumber_js$build$findNumbers$parsePreCandidate")), _isValidPreCandidate = _interopRequireDefault(require("module$node_modules$libphonenumber_js$build$findNumbers$isValidPreCandidate")), _isValidCandidate = function(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
      return {"default":obj};
    }
    if ((nodeInterop = _getRequireWildcardCache(nodeInterop)) && nodeInterop.has(obj)) {
      return nodeInterop.get(obj);
    }
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor, key;
    for (key in obj) {
      if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
      }
    }
    newObj["default"] = obj;
    nodeInterop && nodeInterop.set(obj, newObj);
    return newObj;
  }(require("module$node_modules$libphonenumber_js$build$findNumbers$isValidCandidate")), _metadata = require("module$node_modules$libphonenumber_js$build$metadata"), _parsePhoneNumber = _interopRequireDefault(require("module$node_modules$libphonenumber_js$build$parsePhoneNumber"));
  require = (0,_createExtensionPattern["default"])("matching");
  var INNER_MATCHES = ["\\/+(.*)/", "(\\([^(]*)", "(?:".concat(global.pZ, "-|-").concat(global.pZ, ")").concat(global.pZ, "*(.+)"), "[‒-―－]".concat(global.pZ, "*(.+)"), "\\.+".concat(global.pZ, "*([^.]+)"), "".concat(global.pZ, "+(").concat(global.PZ, "+)")];
  _createExtensionPattern = (0,_util.limit)(0, 2);
  var punctuationLimit = (0,_util.limit)(0, 4), digitBlockLimit = module.MAX_LENGTH_FOR_NSN + module.MAX_LENGTH_COUNTRY_CODE, blockLimit = (0,_util.limit)(0, digitBlockLimit);
  module = "[".concat(module.VALID_PUNCTUATION, "]") + punctuationLimit;
  digitBlockLimit = global.pNd + (0,_util.limit)(1, digitBlockLimit);
  var PATTERN = "(?:" + _isValidCandidate.LEAD_CLASS + module + ")" + _createExtensionPattern + digitBlockLimit + "(?:" + module + digitBlockLimit + ")" + blockLimit + "(?:" + require + ")?", UNWANTED_END_CHAR_PATTERN = new RegExp("[^".concat(global._pN).concat(global._pL, "#]+$")), MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
  global = function() {
    function PhoneNumberMatcher() {
      var text = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "", options = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, metadata = 2 < arguments.length ? arguments[2] : void 0;
      if (!(this instanceof PhoneNumberMatcher)) {
        throw new TypeError("Cannot call a class as a function");
      }
      options = {v2:options.v2, defaultCallingCode:options.defaultCallingCode, defaultCountry:options.defaultCountry && (0,_metadata.isSupportedCountry)(options.defaultCountry, metadata) ? options.defaultCountry : void 0, leniency:options.leniency || (options.extended ? "POSSIBLE" : "VALID"), maxTries:options.maxTries || MAX_SAFE_INTEGER};
      if (!options.leniency) {
        throw new TypeError("`leniency` is required");
      }
      if ("POSSIBLE" !== options.leniency && "VALID" !== options.leniency) {
        throw new TypeError('Invalid `leniency`: "'.concat(options.leniency, '". Supported values: "POSSIBLE", "VALID".'));
      }
      if (0 > options.maxTries) {
        throw new TypeError("`maxTries` must be `\x3e\x3d 0`");
      }
      this.text = text;
      this.options = options;
      this.metadata = metadata;
      this.leniency = _Leniency["default"][options.leniency];
      if (!this.leniency) {
        throw new TypeError('Unknown leniency: "'.concat(options.leniency, '"'));
      }
      this.maxTries = options.maxTries;
      this.PATTERN = new RegExp(PATTERN, "ig");
      this.state = "NOT_READY";
      this.searchIndex = 0;
      this.regExpCache = new _RegExpCache["default"](32);
    }
    _createClass(PhoneNumberMatcher, [{key:"find", value:function() {
      for (var matches; 0 < this.maxTries && null !== (matches = this.PATTERN.exec(this.text));) {
        var candidate = matches[0], offset = matches.index;
        candidate = (0,_parsePreCandidate["default"])(candidate);
        if ((0,_isValidPreCandidate["default"])(candidate, offset, this.text) && (candidate = this.parseAndVerify(candidate, offset, this.text) || this.extractInnerMatch(candidate, offset, this.text))) {
          if (this.options.v2) {
            return {startsAt:candidate.startsAt, endsAt:candidate.endsAt, number:candidate.phoneNumber};
          }
          matches = candidate.phoneNumber;
          candidate = {startsAt:candidate.startsAt, endsAt:candidate.endsAt, phone:matches.nationalNumber};
          matches.country ? candidate.country = matches.country : candidate.countryCallingCode = matches.countryCallingCode;
          matches.ext && (candidate.ext = matches.ext);
          return candidate;
        }
        this.maxTries--;
      }
    }}, {key:"extractInnerMatch", value:function(substring, offset, text) {
      for (var _iterator = _createForOfIteratorHelperLoose(INNER_MATCHES), _step; !(_step = _iterator()).done;) {
        var isFirstMatch = !0, candidateMatch = void 0;
        for (_step = new RegExp(_step.value, "g"); 0 < this.maxTries && null !== (candidateMatch = _step.exec(substring));) {
          if (isFirstMatch) {
            isFirstMatch = (0,_util.trimAfterFirstMatch)(UNWANTED_END_CHAR_PATTERN, substring.slice(0, candidateMatch.index));
            if (isFirstMatch = this.parseAndVerify(isFirstMatch, offset, text)) {
              return isFirstMatch;
            }
            this.maxTries--;
            isFirstMatch = !1;
          }
          var candidate = (0,_util.trimAfterFirstMatch)(UNWANTED_END_CHAR_PATTERN, candidateMatch[1]), candidateIndexGuess = substring.indexOf(candidate, candidateMatch.index);
          if (candidate = this.parseAndVerify(candidate, offset + candidateIndexGuess, text)) {
            return candidate;
          }
          this.maxTries--;
        }
      }
    }}, {key:"parseAndVerify", value:function(candidate, offset, text) {
      if ((0,_isValidCandidate["default"])(candidate, offset, text, this.options.leniency) && (text = (0,_parsePhoneNumber["default"])(candidate, {extended:!0, defaultCountry:this.options.defaultCountry, defaultCallingCode:this.options.defaultCallingCode}, this.metadata)) && text.isPossible() && this.leniency(text, {candidate, defaultCountry:this.options.defaultCountry, metadata:this.metadata, regExpCache:this.regExpCache})) {
        return {startsAt:offset, endsAt:offset + candidate.length, phoneNumber:text};
      }
    }}, {key:"hasNext", value:function() {
      "NOT_READY" === this.state && (this.state = (this.lastMatch = this.find()) ? "READY" : "DONE");
      return "READY" === this.state;
    }}, {key:"next", value:function() {
      if (!this.hasNext()) {
        throw Error("No next element");
      }
      var result = this.lastMatch;
      this.lastMatch = null;
      this.state = "NOT_READY";
      return result;
    }}]);
    return PhoneNumberMatcher;
  }();
  exports["default"] = global;
};

//# sourceMappingURL=module$node_modules$libphonenumber_js$build$PhoneNumberMatcher.js.map
