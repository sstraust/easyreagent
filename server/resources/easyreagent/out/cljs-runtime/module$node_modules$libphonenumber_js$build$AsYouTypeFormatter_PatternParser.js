shadow$provide.module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_PatternParser = function(global, require, module, exports) {
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || !1;
      descriptor.configurable = !0;
      "value" in descriptor && (descriptor.writable = !0);
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    protoProps && _defineProperties(Constructor.prototype, protoProps);
    staticProps && _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {writable:!1});
    return Constructor;
  }
  function expandSingleElementArray(array) {
    return 1 === array.length ? array[0] : array;
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports["default"] = void 0;
  global = function() {
    function PatternParser() {
      if (!(this instanceof PatternParser)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    _createClass(PatternParser, [{key:"parse", value:function(pattern) {
      this.context = [{or:!0, instructions:[]}];
      this.parsePattern(pattern);
      if (1 !== this.context.length) {
        throw Error("Non-finalized contexts left when pattern parse ended");
      }
      var _this$context$ = this.context[0];
      pattern = _this$context$.branches;
      _this$context$ = _this$context$.instructions;
      if (pattern) {
        return {op:"|", args:pattern.concat([expandSingleElementArray(_this$context$)])};
      }
      if (0 === _this$context$.length) {
        throw Error("Pattern is required");
      }
      return 1 === _this$context$.length ? _this$context$[0] : _this$context$;
    }}, {key:"startContext", value:function(context) {
      this.context.push(context);
    }}, {key:"endContext", value:function() {
      this.context.pop();
    }}, {key:"getContext", value:function() {
      return this.context[this.context.length - 1];
    }}, {key:"parsePattern", value:function(pattern) {
      if (!pattern) {
        throw Error("Pattern is required");
      }
      var match = pattern.match(OPERATOR);
      if (match) {
        var operator = match[1], before = pattern.slice(0, match.index);
        pattern = pattern.slice(match.index + operator.length);
        switch(operator) {
          case "(?:":
            before && this.parsePattern(before);
            this.startContext({or:!0, instructions:[], branches:[]});
            break;
          case ")":
            if (!this.getContext().or) {
              throw Error('")" operator must be preceded by "(?:" operator');
            }
            before && this.parsePattern(before);
            if (0 === this.getContext().instructions.length) {
              throw Error('No instructions found after "|" operator in an "or" group');
            }
            before = this.getContext().branches;
            before.push(expandSingleElementArray(this.getContext().instructions));
            this.endContext();
            this.getContext().instructions.push({op:"|", args:before});
            break;
          case "|":
            if (!this.getContext().or) {
              throw Error('"|" operator can only be used inside "or" groups');
            }
            before && this.parsePattern(before);
            if (!this.getContext().branches) {
              if (1 === this.context.length) {
                this.getContext().branches = [];
              } else {
                throw Error('"branches" not found in an "or" group context');
              }
            }
            this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));
            this.getContext().instructions = [];
            break;
          case "[":
            before && this.parsePattern(before);
            this.startContext({oneOfSet:!0});
            break;
          case "]":
            if (!this.getContext().oneOfSet) {
              throw Error('"]" operator must be preceded by "[" operator');
            }
            this.endContext();
            operator = this.getContext().instructions;
            match = operator.push;
            for (var values = [], i = 0; i < before.length;) {
              if ("-" === before[i]) {
                if (0 === i || i === before.length - 1) {
                  throw Error("Couldn't parse a one-of set pattern: ".concat(before));
                }
                for (var prevValue = before[i - 1].charCodeAt(0) + 1, nextValue = before[i + 1].charCodeAt(0) - 1; prevValue <= nextValue;) {
                  values.push(String.fromCharCode(prevValue)), prevValue++;
                }
              } else {
                values.push(before[i]);
              }
              i++;
            }
            match.call(operator, {op:"[]", args:values});
            break;
          default:
            throw Error("Unknown operator: ".concat(operator));
        }
        pattern && this.parsePattern(pattern);
      } else {
        if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {
          throw Error("Illegal characters found in a pattern: ".concat(pattern));
        }
        this.getContext().instructions = this.getContext().instructions.concat(pattern.split(""));
      }
    }}]);
    return PatternParser;
  }();
  exports["default"] = global;
  var ILLEGAL_CHARACTER_REGEXP = /[\(\)\[\]\?:\|]/, OPERATOR = RegExp("(\\||\\(\\?\\:|\\)|\\[|\\])");
};

//# sourceMappingURL=module$node_modules$libphonenumber_js$build$AsYouTypeFormatter_PatternParser.js.map
